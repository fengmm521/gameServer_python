#!/usr/bin/env python# -*- coding: utf-8 -*-import Cmds_pb2import timeimport erroflogimport askMysqlTypeimport taskimport Emailimport UserTimesimport randomimport copy from Hero import _Herofrom Item import _Itemfrom Hero import _HeroSkillfrom UserBase import _UserBasefrom UserConnectCacheT import T_MSGHEAD_Tfrom UserOtherData import _UserOtherDatafrom BatmanInfo import _BatmanInfofrom Resource import _Resourceclass User():    def __init__(self,account,clientobj,userCacheT):                self.userCacheT = userCacheT   #用户线程池回调        #用户帐号数据        self.account = account        self.csocket = None        self.token = 0        self.pw = ''        self.phone = ''        self.userType = ''        self.machingNumber = ''        self.relogintimes = 0                       #补签次数        self.rechargeValue = 0                      #玩家已充值元宝数量        self.lastShopRefreshTime = 0                #商城上次刷新时间        self.shopgoods = []        #用户游戏数据        self.lastLoginTime = 0                     #上次签到时间        self.resouce = _Resource()                  #玩家资源数据        self.userBase = _UserBase()       #玩家基础数据        self.userOtherData = _UserOtherData()       #玩家其他数据        self.userTimes = UserTimes.UserTimes(self)                self.userBuffs = {}                         #玩家buff信息        self.batmanInfo = _BatmanInfo()             #小兵技能等级信息,这里保存了所有小兵等级信息,小兵等级信息更改时，会保存所有小兵等级        self.activityIds = []                       #游戏活动编号        self.heros = {}        self.heroConfigs = {}                       #{'英雄配置ID':英雄网络ID},可以通过此map获取英雄网络ID        self.changeHeros = []                       #玩家更改过的英雄，等级，品质，品阶，主城阵容出战等信息        self.items = {}        self.itemIndex = 1                          #道具临时ID从数字1开始        self.itemsNumbers = {}                      #未保存到数据库的新获取道具{临时ID:配置ID}        self.changeItems = []                       #玩家更改过的道具，等级，品质，数量，穿戴等，在修改好并发送给客户端成功之后会保存到数据库。这里记录下一步要保存更新到数据库的道网络ID        self.heroSkills = {}                        #武将技能{技能网络ID:技能}        self.heroskillTmpID = 0        self.heroSkillConfigs = {}                  #英雄技能临时ID对应的网络ID{技能临时ID:技能配置ID}        self.skillForHeros = {}                     #{技能临时ID或者技能网络ID:技能英雄网络ID}                self.addEnergyTime = int(time.time())   #上次增加粮草时间                                #关卡        self.stageHurdle1 = 0                       #简单难度打通关卡号        self.stageHurdle2 = 0                       #普通难度打通关卡号        self.stageHurdle3 = 0                       #困难难度打通关卡号                self.nowStageHurdle = 0                    #当前正在打的关卡ID        self.nowStageType = 0                       #汉前正在打的关卡难度        self.nowStageStartTime = 0        #关卡保存地图        self.mappoints = {}                         #{地图网络id:[0,1,2,3,4,...]}    一共30个塔位,地图网络id由帐号字符串+关卡id字符串组成        self.mapIDs = {}                            #{str(mapid):地图网络id},客户端传来的地图id保存成字符串，        #数据库        self.mysqlAsks = {}                         #数据库已发送请求列队{askid:[backFunc]}                        self.userOutHeros = [0,0,0]                 #玩家的三个主城阵容武将        self.userStageHeros = [0,0,0,0,0,0,0,0,0]   #玩家的九个战斗阵容武将                #商城已购买道具        self.BuyedItems = {}                        #{storeid:count},购买的商城id,已购买数量        self.BuyedItemsTime = {}                    #{storeid:time},购买的商城id,上次购买时间                #任务        self.task = task.task(self) #初始化任务        #邮件        self.Email = Email.Email(self)        self.isNewEmail = False                     #玩家是否有新邮件        self.isNewPush = False                      #玩家接收到新邮件消息是否推送        self.csocket = None          self.sendIndex = 1        #公会        self.tongID = 0  #公会id        self.tongmemberID = 0 #公会成员id        self.tokenLastCallTime = int(time.time())   #用户token过期时间,每一次用户请求时这一定时器都会记录上次请求时间        self._initUserAccountWithClientObj(clientobj)            #向玩家推送邮件信息    def pushNewEmail(self):        if self.isNewPush:#新邮件已经向玩家推送过了。不再推送            return        emails = self.Email.getNewEmailIDs()        cpdat = Cmds_pb2.PushEmail()        for ei in emails:            cpdat.pEmailIDs.append(ei)        csenddat = cpdat.SerializePartialToString()        handlertmp =  T_MSGHEAD_T()        self.sendIndex += 1        handlertmp.idx = self.sendIndex        handlertmp.cmd = 11022 #使用获取邮件列表的推送接口        handlertmp.enc = 0        handlertmp.eno = 0        handlertmp.com = 2      #com的第1位表示是否压缩，com的第二位表示是否推送        handlertmp.cmd = 13002  #新邮件推送接口        handlertmp.len = len(csenddat)        csenddat = handlertmp.getStructDat() + csenddat        if self.csocket:            try:                self.csocket.send(csenddat)                self.isNewPush = True            except EOFError:                  print '用户收到新邮件，向玩家推送新邮件,错误码:'                 print EOFError              except:                  print '用户收到新邮件，向玩家推送新邮件推送数据错误'    #从数据库中取出玩家新邮件数据    def getNewEamilDataFromDB(self,callback = None):        emails = self.Email.getNewEmailIDs()        if self.isNewEmail and emails:              def selectNewEmailFunc(datas,pEmails = emails,cback = callback):                self.Email.setNewEmailFromOtherType(datas)                self.isNewEmail = False                     #玩家所有新邮件已取出                if cback:                    self.Email.getNewEmailIDsFromSQLDB()                    cback()            self.sreachUserDataFromMysql(emails, askMysqlType.SQL_selectEmail, selectNewEmailFunc)#从数据库中获取邮件    def receiveEmailFromOther(self,emailNid,emailType):        self.Email.addNewEmailFromOtherWithType(emailNid,emailType)        def getEmailDataFromMySql(emNid = emailNid):            self.pushNewEmail()        self.getNewEamilDataFromDB(getEmailDataFromMySql)    #删除邮件    def deleEmailWithIDFromDB(self,emailSqlID,callback = None):        self.Email.deleteEmailWithNID(emailSqlID)        self.deleteUserDataFromMysql(emailSqlID, askMysqlType.SQL_DeleteEmail, callback)    #向其他帐号发送邮件    def sendEmailIDToUserManger(self,emailNid,emailType,acc):        self.userCacheT.sendEmailDataToUserManger(self.userBase.name,acc,emailNid,emailType)            def sendUserEmailToAccount(self,cgdat,acc):        #先将邮件数据存入数据库        receiveName = cgdat.receiveName        pText = cgdat.pText        emailType = cgdat.emailType        #eType,eTitle,eContent,eNid,eLookType = EmailFlog.flog_elTypeUnLook):        sendemailData = Email.EmailData(emailType,receiveName,pText)        sendemailData.setReward(self.userBase.name, acc, '', '', '')        tid = self.Email.setSendEmailData(sendemailData)        def saveSendEmailFunc(emailnid,acc):            self.sendEmailIDToUserManger(emailnid,acc)        self.insetUserDataToMysql(tid, askMysqlType.SQL_InsetEmail,saveSendEmailFunc)#保存发送邮件到邮件列表# message RequestSendEmail# {    #     optional bytes sendName = 1;                //发送邮件用户名#     optional bytes receiveName = 2;             //接收邮件用户名#     optional bytes pText = 3;                    //邮件内容#     optional int32 itemNetIDs = 4;                //用邮件向其他玩家发送道具#     optional int32 HeroNetIDs = 5;                //用邮件向其他玩家发送英雄，此功能可能没有，写数据时可以留空#     optional Resource res = 6;                    //用邮件发送给其他玩家资源#     optional int32 emailType = 7;                //邮件类型2,玩客信息,7.到付邮件（到付邮件在玩家交换物品时使用）8.到付邮件被退回# }        #再将发出的邮件ID信息发送给用户管理线程    def getHeroSkillNewIndex(self,heroskillCID):        self.heroskillTmpID += 1        if self.heroskillTmpID > 800:            self.heroskillTmpID = 1        self.heroSkillConfigs[self.heroskillTmpID] = heroskillCID        return self.heroskillTmpID    def getItemNewIndex(self,itemcid):#临时保存的道具id        self.itemIndex += 1        if self.itemIndex > 1000:            self.itemIndex = 1        self.itemsNumbers[self.itemIndex] = itemcid        return self.itemIndex    #创建新玩家帐号游戏数据    def createUserWithBaseConfig(self):        beginconf = self.userCacheT.getConfigDataWithTableNameAndID('tab_begin',1)        self.userBase.level = int(beginconf['level'])        self.resouce.acer = int(beginconf['acer'])        self.resouce.book = int(beginconf['book'])        self.resouce.copper = int(beginconf['copper'])        self.resouce.feats = int(beginconf['feats'])        self.resouce.forage = int(beginconf['forage'])        self.resouce.friendpoint = int(beginconf['friendpoint'])        self.resouce.medal = int(beginconf['medal'])        self.resouce.soul = int(beginconf['soul'])        heroids = [int(beginconf['hero1']),int(beginconf['hero2'])]        self._InitBaseHeros(heroids)#初始化英雄        itemsids = str(beginconf['items'])        itemids = []        if itemsids != 'null':            itemsids = itemsids.split(';')            for ix in itemsids:                tmpidx = self.getItemNewIndex(int(ix))                itemids.append(tmpidx)            self._InitBaseItems(itemids,int(beginconf['itemcount']))#初始化道具        heroskillids = self.skillForHeros.keys()        self._InitBaseHeroSkills(heroskillids)#初始化英雄技能    def _initBaseHerosFromMysqlData(self,datas):        self.heros.clear()        for htmp in datas:            tmphero = _Hero()            tmphero.heroNetID = int(htmp[0])            tmphero.heroCID = int(htmp[1])            tmphero.heroLevel = int(htmp[3])            tabheroinfo = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroInfo',int(htmp[1]))            tmphero.heroStar = int(htmp[4])            tmphero.heroUserID = self.account            tmpskilltid = self.getHeroSkillNewIndex(int(tabheroinfo['skillId']))            tmphero.skillNetID = tmpskilltid            tmphero.isOutHero = int(htmp[5])            tmphero.herodiff = 0            tmphero.heroLastType = 0            tmphero.heroLastTime = 0            self.heros[tmphero.heroNetID] = tmphero              self.heroConfigs[tmphero.heroCID] = tmphero.heroNetID            self.skillForHeros[tmpskilltid] = tmphero.heroCID  #记录英雄技能所对应的英雄ID    def _InitBaseHeros(self,hids):                   #初始化新帐号英雄数据,42284,42006        self.heros.clear()        self.heroConfigs.clear()        self.skillForHeros.clear()        for i in hids:            tmphero = _Hero()            tmphero.heroNetID = i            tmphero.heroCID = i            tmphero.heroLevel = 1            tabheroinfo = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroInfo',i)            tmphero.heroStar = int(tabheroinfo['starInit']) #武将品阶最小值            tmphero.heroUserID = self.account            tmpskilltid = self.getHeroSkillNewIndex(int(tabheroinfo['skillId']))            tmphero.skillNetID = tmpskilltid            tmphero.herodiff = 0            tmphero.heroLastType = 0            tmphero.heroLastTime = 0            self.heros[tmphero.heroNetID] = tmphero              self.heroConfigs[tmphero.heroCID] = tmphero.heroNetID            self.skillForHeros[tmpskilltid] = tmphero.heroCID  #记录英雄技能所对应的英雄ID    def _insetNewHeroWithID(self,hids):        addskilliDs = []        for i in hids:            tmphero = _Hero()            tmphero.heroNetID = i            tmphero.heroCID = i            tmphero.heroLevel = 1            tabheroinfo = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroInfo',i)            tmphero.heroStar = int(tabheroinfo['starInit']) #武将品阶最小值            tmphero.heroUserID = self.account            tmpskilltid = self.getHeroSkillNewIndex(int(tabheroinfo['skillId']))            tmphero.skillNetID = tmpskilltid            tmphero.herodiff = 0            tmphero.heroLastType = 0            tmphero.heroLastTime = 0            self.heros[tmphero.heroNetID] = tmphero              self.heroConfigs[tmphero.heroCID] = tmphero.heroNetID            self.skillForHeros[tmpskilltid] = tmphero.heroNetID  #记录英雄技能所对应的英雄ID            addskilliDs.append(tmpskilltid)     #技能ids        #添加新英雄的英雄技能        self._insetNewHeroSkill(addskilliDs)        return hids,addskilliDs    def _initBaseItemWithMysqlDAta(self,datas):        self.items.clear()        #`netid`,  `account`,`toolconfigID`, `level`, `quality`, `star`, `count`, `itemUsedID`, `itemuseTime`        #((200004L, 10001L, u'test123476', 1L, 0L, 0L, 2L, -1L, 0L), (200005L, 21000L, u'test123476', 1L, 0L, 1L, 1L, -1L, 0L))        for itmp in datas:            tmp = _Item()            tmp.itemNetID = itmp[0]            tmp.itemCID = itmp[1]            tmp.itemLevel = itmp[3]            tmp.itemStar = itmp[5]            tmp.itemQuality = itmp[4]            tmp.itemNumber = itmp[6]            tmp.itemUsedID = itmp[7]            tmp.itemuseTime = itmp[8]            tmp.itemType = itmp[9]            self.items[tmp.itemNetID] = tmp    def _InitBaseItems(self,itemids,incount = 1):        self.items.clear()        for i in itemids:            tmp = _Item()            tmp.itemNetID = i            tmp.itemCID = self.itemsNumbers[i]            iteminfo = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',self.itemsNumbers[i])            tmp.itemLevel = 1            tmp.itemStar = 0            tmp.itemQuality = int(iteminfo['rank'])            tmp.itemNumber = incount            tmp.itemUsedID = 0            tmp.itemuseTime = 0            tmp.itemType = int(iteminfo['equipCoordinate']) #装备部位            self.items[tmp.itemNetID] = tmp    def _InitBaseHeroSkillsWithMysqlData(self,datas):        self.heroSkills.clear()        #`id`, `account`, `configid`, `level`, `skillType`, `quality`, `getpath`, `skillHeroNetID`, `uptime`        #((10015L, u'usertest154', 284L, 1L, 0L, 0L, 0L, 42284L, 0L), (10016L, u'usertest154', 6L, 1L, 0L, 0L, 0L, 42006L, 0L))        for stmp in datas:            tmp = _HeroSkill()            tmp.skillNetID = stmp[0]            tmp.skillCID = stmp[2]            tmp.skillLevel = stmp[3]            tmp.skillHeroNetID = stmp[7]            tmp.skillType = stmp[4]            self.heroSkills[tmp.skillNetID] = tmp    def _InitBaseHeroSkills(self,heroskillids):        self.heroSkills.clear()        for i in heroskillids:            tmp = _HeroSkill()            tmp.skillNetID = i            tmp.skillCID = self.heroSkillConfigs[i]            tmp.skillLevel = 1            tmp.skillHeroNetID = self.skillForHeros.pop(tmp.skillNetID)            tmp.skillType = 0            self.heroSkills[tmp.skillNetID] = tmp    def _insetNewHeroSkill(self,heroskillids):        for i in heroskillids:            tmp = _HeroSkill()            tmp.skillNetID = i            tmp.skillCID = self.heroSkillConfigs[i]            tmp.skillLevel = 1            tmp.skillHeroNetID = self.skillForHeros.pop(tmp.skillNetID)            tmp.skillType = 0            self.heroSkills[tmp.skillNetID] = tmp    def initStoreItems(self):#初始化商城可购买信息        pass    #玩家登陆成功，通过玩家帐号从数据库中获取玩家数据    def createUserDataFromMysql(self):        self.sreachUserDataFromMysql('', askMysqlType.SQL_SelectLoginAccount)    #通过武将网络ID获得武将战力    def _getHeroFightingWithHeroNetID(self,netID):        pass    #通过道具网络ID获得道具战力    def _getItemFightingWithItemNetID(self,netID):        pass    #收到用户管理器发来的消息     def receiveDataFromUserMangerT(self,userobj):        if userobj.dataType == 'clientobj':            self._initUserAccountWithClientObj(userobj.data)        if userobj.dataType == 'email':            self.receiveEmailFromOther(userobj.data,userobj.csocket)    def receiveClientDataFromConnectCache(self,clientobj):        #clientobj = ClientObj.ClientObj(datstr,handler,handler.cmd,clientSocket,clientIP)#dat,handler,dataType,csocket,ipAddr        if clientobj.handler.cmd == 11001:#修改用户头像，用户名，头像框            pass        elif clientobj.handler.cmd == 11002:#获取用户数据            sdat = self.getUserDataToClientWithString11002()            handlertmp = clientobj.handler            handlertmp.len = len(sdat)            handlertmp.eno = 0            handlertmp.enc = 0            handlertmp.com = 0            sdat = handlertmp.getStructDat() + sdat            try:                  clientobj.csocket.send(sdat)            except EOFError:                  print '11002获取用户数据后向客户端送数据错误,错误码:'                 print EOFError              except:                  print '11002获取用户数据后向客户端送数据错误'                    elif clientobj.handler.cmd == 11003:#玩家增加士气计时结束请求            pass        elif clientobj.handler.cmd == 11073:#购买铜钱            cgdat = Cmds_pb2.RequestBuyCopper()            cgdat.ParseFromString(clientobj.data)            buys = cgdat.buyTimes            viptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_opration_list_vip',self.userBase.vipLevel)            lasttime = time.localtime(self.userTimes.lastBuyCopperTime) #上次签到时间            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_yday != lasttime.tm_yday:                self.userTimes.buyCopperTimes = 0            if self.userTimes.buyCopperTimes + buys> int(viptab['copperTime']):#铜钱购买已达上限                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_HeaveMaxBuyCount #已达最大购买上限                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11073向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11073向客户端送数据错误'            else:                buytime = self.userTimes.buyCopperTimes + buys                if buytime > 10:                    buytime = 10                buyid = 2*100 + buytime +1                buytab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',buyid)                castgood = self.splitCastGoodsWithOneStrToIntDats(str(buytab['consume']), splitstr = ';')                resold = self.resouce.getResWithNameOrType(castgood[0])                if resold >= (castgood[2]*buys):                    self.resouce.setResWithNameOrType(castgood[0], resold - (castgood[2]*buys))                    self.resouce.copper += (int(buytab['times'])*buys)                    self.userTimes.lastBuyCopperTime = int(time.time())                    self.userTimes.buyCopperTimes += buys                    def updataResFunc(moneytype = castgood[0],cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseBuyCopper()                        cpdat.heaveBuyTimes = self.userTimes.buyCopperTimes                        self.resouce.getResourceForProtobuff(cpdat.res, moneytype)                        self.resouce.getResourceForProtobuff(cpdat.res, 2)#铜钱                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11002获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11002获取用户数据后向客户端送数据错误'                    self.updateUserDataToMysql('buycopper', askMysqlType.SQL_UpdataAccountTab, updataResFunc)                else:#元宝不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao #元宝不足                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11073向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11073向客户端送数据错误'        elif clientobj.handler.cmd == 11074:#购买粮草            cgdat = Cmds_pb2.RequestBuyForage()            cgdat.ParseFromString(clientobj.data)            buys = cgdat.buyTimes            viptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_opration_list_vip',self.userBase.vipLevel)            lasttime = time.localtime(self.userTimes.lastBuyForageTime) #上次签到时间            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_yday != lasttime.tm_yday:                self.userTimes.buyForageTimes = 0            if self.userTimes.buyForageTimes + buys > int(viptab['forageTime']):#粮草购买已达上限                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_HeaveMaxBuyCount #已达最大购买上限                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11073向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11073向客户端送数据错误'            else:                buytime = self.userTimes.buyForageTimes + buys                if buytime > 10:                    buytime = 10                buyid = 3*100 + buytime +1                buytab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',buyid)                castgood = self.splitCastGoodsWithOneStrToIntDats(str(buytab['consume']), splitstr = ';')                resold = self.resouce.getResWithNameOrType(castgood[0])                if resold >= (castgood[2]*buys):                    self.resouce.setResWithNameOrType(castgood[0], resold - (castgood[2]*buys))                    self.resouce.forage += (int(buytab['times'])*buys)                    self.userTimes.lastBuyForageTime = int(time.time())                    self.userTimes.buyForageTimes += buys                    def updataResFunc(moneytype = castgood[0],cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseBuyCopper()                        cpdat.heaveBuyTimes = self.userTimes.buyForageTimes                        self.resouce.getResourceForProtobuff(cpdat.res, moneytype)                        self.resouce.getResourceForProtobuff(cpdat.res, 5)#粮草                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11002获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11002获取用户数据后向客户端送数据错误'                    self.updateUserDataToMysql('buyforage', askMysqlType.SQL_UpdataAccountTab, updataResFunc)                else:#元宝不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao #元宝不足                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11073向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11073向客户端送数据错误'        elif clientobj.handler.cmd == 11075:#购买军机处调战            cgdat = Cmds_pb2.RequestBuyPKTimes()            cgdat.ParseFromString(clientobj.data)            buys = cgdat.buyTimes            viptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_opration_list_vip',self.userBase.vipLevel)            lasttime = time.localtime(self.userTimes.lastBuyPKTime) #上次签到时间            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_yday != lasttime.tm_yday:                self.userTimes.buyPKtimes = 0            if self.userTimes.buyPKtimes + buys > int(viptab['arenaTime']):#粮草购买已达上限                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_HeaveMaxBuyCount #已达最大购买上限                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11073向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11073向客户端送数据错误'            else:                buytime = self.userTimes.buyPKtimes + buys                if buytime > 10:                    buytime = 10                buyid = 4*100 + buytime +1                buytab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',buyid)                castgood = self.splitCastGoodsWithOneStrToIntDats(str(buytab['consume']), splitstr = ';')                resold = self.resouce.getResWithNameOrType(castgood[0])                if resold >= (castgood[2]*buys):                    self.resouce.setResWithNameOrType(castgood[0], resold - (castgood[2]*buys))                    self.userTimes.canPKTimes += (int(buytab['times'])*buys)                    self.userTimes.lastBuyPKTime = int(time.time())                    self.userTimes.buyPKtimes += buys                    def updataResFunc(moneytype = castgood[0],cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseBuyCopper()                        cpdat.PKTimes = self.userTimes.canPKTimes                        cpdat.heaveBuyTimes = self.userTimes.buyPKtimes                        self.resouce.getResourceForProtobuff(cpdat.res, moneytype)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11002获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11002获取用户数据后向客户端送数据错误'                    self.updateUserDataToMysql('buyPK', askMysqlType.SQL_UpdataAccountTab, updataResFunc)                else:#元宝不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao #元宝不足                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11073向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11073向客户端送数据错误'        elif clientobj.handler.cmd == 11067:#购买试练塔调战            cgdat = Cmds_pb2.RequestBuyShiLianTimes()            cgdat.ParseFromString(clientobj.data)            buys = cgdat.buyTimes            viptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_opration_list_vip',self.userBase.vipLevel)            lasttime = time.localtime(self.userTimes.lastBuyTowerTime) #上次签到时间            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_yday != lasttime.tm_yday:                self.userTimes.buyShiLianTimes = 0            if self.userTimes.buyShiLianTimes + buys > int(viptab['trialTime']):#粮草购买已达上限                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_HeaveMaxBuyCount #已达最大购买上限                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11073向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11073向客户端送数据错误'            else:                buytime = self.userTimes.buyShiLianTimes + buys                if buytime > 10:                    buytime = 10                buyid = 5*100 + buytime +1                buytab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',buyid)                castgood = self.splitCastGoodsWithOneStrToIntDats(str(buytab['consume']), splitstr = ';')                resold = self.resouce.getResWithNameOrType(castgood[0])                if resold >= (castgood[2]*buys):                    self.resouce.setResWithNameOrType(castgood[0], resold - (castgood[2]*buys))                    self.userTimes.canShiLianTimes += (int(buytab['times'])*buys)                    self.userTimes.lastBuyTowerTime = int(time.time())                    self.userTimes.buyShiLianTimes += buys                    def updataResFunc(moneytype = castgood[0],cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseBuyCopper()                        cpdat.heaveBuyTimes = self.userTimes.buyShiLianTimes                        cpdat.PKTimes = self.userTimes.canShiLianTimes                        self.resouce.getResourceForProtobuff(cpdat.res, moneytype)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11002获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11002获取用户数据后向客户端送数据错误'                    self.updateUserDataToMysql('buyShiLian', askMysqlType.SQL_UpdataAccountTab, updataResFunc)                else:#元宝不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao #元宝不足                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11073向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11073向客户端送数据错误'        elif clientobj.handler.cmd == 11008:#使用道具            cgdat = Cmds_pb2.RequestUseOtherItem()            cgdat.ParseFromString(clientobj.data)            uitemnid = cgdat.itemNetID            ucount = cgdat.useNumber            if ucount < 1:                ucount = 1            if not self.items.has_key(uitemnid):                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_itemNetIDErro #物品网络ID不存在                handlertmp.enc = 0                handlertmp.com = 0                sdat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(sdat)                except EOFError:                      print '11008获取用户数据后向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11008获取用户数据后向客户端送数据错误'                return            else:                itemtmp = self.items[uitemnid]                if itemtmp.itemCID == 10010:#招商令,刷新商店                    self.lastShopRefreshTime = 0 #重置商店刷新时间                    if itemtmp.itemNumber <= 1:                        def mysqlcallbackFunc1(itemnidx = uitemnid,cliobj = clientobj):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            itemsend = cpdat.pItem.add()                            item2 = self.items.pop(itemnidx)                            item2.itemNumber = 0                            item2.getItemDataForProtobuff(itemsend)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems, mysqlcallbackFunc1)                    else:                        self.items[uitemnid].itemNumber -= 1                        def mysqlcallbackFunc2(itemnidx = uitemnid,cliobj = clientobj):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            itemsend = cpdat.pItem.add()                            self.items[itemnidx].getItemDataForProtobuff(itemsend)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems, mysqlcallbackFunc2)                elif itemtmp.itemCID == 10007 or itemtmp.itemCID == 10004:#铜钥匙                    findnid = 10007                    if itemtmp.itemCID == 10007:                        findnid = 10004                    boxnid = 0                    for itx in self.items.keys():                        if self.items[itx].itemCID == findnid:                            boxnid = itx                            break                    if boxnid > 0:                        if self.items[boxnid].itemNumber <= 1 and self.items[uitemnid].itemNumber <= 1:                            def mysqlCallbackfunc3(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                itemtmp1 = self.items.pop(itemnid1)                                itemtmp1.getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc3)                        elif self.items[boxnid].itemNumber <= 1:                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        elif self.items[uitemnid].itemNumber <= 1:                            self.items[boxnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        else:                            self.items[boxnid].itemNumber -= 1                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                self.items[itemnid2].getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                    else:                        handlertmp = clientobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_NoBoxOrNoKey  #没有宝箱，或者没有钥匙                        handlertmp.len = 0                        csenddat = handlertmp.getStructDat()                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11008获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11008获取用户数据后向客户端送数据错误'                elif itemtmp.itemCID == 10008 or itemtmp.itemCID == 10005:#银钥匙                    findnid = 10008                    if itemtmp.itemCID == 10008:                        findnid = 10005                    boxnid = 0                    for itx in self.items.keys():                        if self.items[itx].itemCID == findnid:                            boxnid = itx                            break                    if boxnid > 0:                        if self.items[boxnid].itemNumber <= 1 and self.items[uitemnid].itemNumber <= 1:                            def mysqlCallbackfunc3(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                itemtmp1 = self.items.pop(itemnid1)                                itemtmp1.getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc3)                        elif self.items[boxnid].itemNumber <= 1:                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        elif self.items[uitemnid].itemNumber <= 1:                            self.items[boxnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        else:                            self.items[boxnid].itemNumber -= 1                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                self.items[itemnid2].getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                    else:                        handlertmp = clientobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_NoBoxOrNoKey  #没有宝箱，或者没有钥匙                        handlertmp.len = 0                        csenddat = handlertmp.getStructDat()                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11008获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11008获取用户数据后向客户端送数据错误'                elif itemtmp.itemCID == 10009 or itemtmp.itemCID == 10006:#金钥匙                    findnid = 10009                    if itemtmp.itemCID == 10009:                        findnid = 10006                    boxnid = 0                    for itx in self.items.keys():                        if self.items[itx].itemCID == findnid:                            boxnid = itx                            break                    if boxnid > 0:                        if self.items[boxnid].itemNumber <= 1 and self.items[uitemnid].itemNumber <= 1:                            def mysqlCallbackfunc3(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                itemtmp1 = self.items.pop(itemnid1)                                itemtmp1.getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc3)                        elif self.items[boxnid].itemNumber <= 1:                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = uitemnid,itemnid2 = boxnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(boxnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        elif self.items[uitemnid].itemNumber <= 1:                            self.items[boxnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                itemtmp2 = self.items.pop(itemnid2)                                itemtmp2.getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                        else:                            self.items[boxnid].itemNumber -= 1                            self.items[uitemnid].itemNumber -= 1                            def mysqlCallbackfunc32(cliobj = clientobj,itemnid1 = boxnid,itemnid2 = uitemnid):                                cpdat = Cmds_pb2.ResponseUseOtherItem()                                sitem1 = cpdat.pItem.add()                                self.items[itemnid1].getItemDataForProtobuff(sitem1)                                sitem2 = cpdat.pItem.add()                                self.items[itemnid2].getItemDataForProtobuff(sitem2)                                self.resouce.getResourceForProtobuff(cpdat.res, 2)                                csenddat = cpdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.com = 0                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.len = len(csenddat)                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                      cliobj.csocket.send(csenddat)                                except EOFError:                                      print '11008获取用户数据后向客户端送数据错误,错误码:'                                     print EOFError                                  except:                                      print '11008获取用户数据后向客户端送数据错误'                                return                            self.updateUserDataToMysql(boxnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,mysqlCallbackfunc32)                    else:                        handlertmp = clientobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_NoBoxOrNoKey  #没有宝箱，或者没有钥匙                        handlertmp.len = 0                        csenddat = handlertmp.getStructDat()                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11008获取用户数据后向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11008获取用户数据后向客户端送数据错误'                elif itemtmp.itemCID == 10001:#初始粮草                    self.resouce.forage += (10*ucount)                    if self.items[uitemnid].itemNumber <= 1:                        def mysqlcallbackFunc6(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            itemx2 = self.items.pop(itemnidx)                            pitems = cpdat.pItem.add()                            itemx2.getItemDataForProtobuff(pitems)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackFunc6)                    else:                        self.items[uitemnid].itemNumber -= 1                        def mysqlcallbackfunc7(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            pitem = cpdat.pItem.add()                            self.items[itemnidx].getItemDataForProtobuff(pitem)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackfunc7)                elif itemtmp.itemCID == 10002:#中级粮草                    self.resouce.forage += (30*ucount)                    if self.items[uitemnid].itemNumber <= 1:                        def mysqlcallbackFunc6(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            itemx2 = self.items.pop(itemnidx)                            pitems = cpdat.pItem.add()                            itemx2.getItemDataForProtobuff(pitems)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackFunc6)                    else:                        self.items[uitemnid].itemNumber -= 1                        def mysqlcallbackfunc7(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            pitem = cpdat.pItem.add()                            self.items[itemnidx].getItemDataForProtobuff(pitem)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackfunc7)                elif itemtmp.itemCID == 10003:#高级粮草                    self.resouce.forage += (50*ucount)                    if self.items[uitemnid].itemNumber <= 1:                        def mysqlcallbackFunc6(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            itemx2 = self.items.pop(itemnidx)                            pitems = cpdat.pItem.add()                            itemx2.getItemDataForProtobuff(pitems)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.deleteUserDataFromMysql(uitemnid, askMysqlType.SQL_DeleteItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackFunc6)                    else:                        self.items[uitemnid].itemNumber -= 1                        def mysqlcallbackfunc7(cliobj = clientobj,itemnidx = uitemnid):                            cpdat = Cmds_pb2.ResponseUseOtherItem()                            self.resouce.getResourceForProtobuff(cpdat.res, 5)                            pitem = cpdat.pItem.add()                            self.items[itemnidx].getItemDataForProtobuff(pitem)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.len = len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11008获取用户数据后向客户端送数据错误,错误码:'                                 print EOFError                              except:                                  print '11008获取用户数据后向客户端送数据错误'                        self.updateUserDataToMysql(uitemnid, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, mysqlcallbackfunc7)                else:                    #Erro_itemNotUsedInBag                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_itemNotUsedInBag                    handlertmp.len = 0                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11008获取用户数据后向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11008获取用户数据后向客户端送数据错误'                #goodtab = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',itemtmp.itemCID)        elif clientobj.handler.cmd == 11060:#保存塔点数据            cgdat = Cmds_pb2.RequestCreateStagePoint()            cgdat.ParseFromString(clientobj.data)            stageid = cgdat.stageID            ptype = cgdat.pType            pos = cgdat.pos            print cgdat            poid = str(self.account) + str(stageid)            isHeaveMysql = False            if self.mappoints.has_key(poid):                self.mappoints[poid][pos] = ptype                isHeaveMysql = True            else:                self.mappoints[poid] = [0]*31                self.mappoints[poid][pos] = ptype            if ptype <= 6:                soliderid = self.batmanInfo.getBatmanDatWithNumber(ptype)                batmantab = self.userCacheT.getConfigDataWithTableNameAndID('tab_batmanAttr',soliderid)                castcopper = int(batmantab['buildPrice'])                print soliderid                print ptype                print 'castcopper=%d'%(castcopper)                print 'self.resouce.copper=%d'%(self.resouce.copper)                if castcopper < self.resouce.copper:                    self.resouce.copper -= castcopper                    def createpoint(cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseCreateStagePoint()                        self.resouce.getResourceForProtobuff(cpdat.res, 2)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.eno = 0                        handlertmp.com = 0                        handlertmp.enc = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11060,发送数据错误,错误码:'                             print EOFError                          except:                            print '11060,客户端发送数据错误'                    if isHeaveMysql:                        self.updateUserDataToMysql([poid,pos,stageid], askMysqlType.SQL_UpdateMapPoint)                    else:                        self.insetUserDataToMysql([poid,pos,stageid], askMysqlType.SQL_InsetMapPoint)                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, createpoint)                else:#放置资源不足                    self.mappoints[poid][pos] = 0                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.enc = 0                    handlertmp.com = 0                    try:                        clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                        print '11060,发送数据错误,错误码:'                         print EOFError                      except:                        print '11060,客户端发送数据错误'            else:                def createpoint(cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseCreateStagePoint()                    self.resouce.getResourceForProtobuff(cpdat.res, 2)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.len = len(csenddat)                    handlertmp.eno = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    csenddat = handlertmp.getStructDat() + csenddat                    try:                        cliobj.csocket.send(csenddat)                    except EOFError:                        print '11060,发送数据错误,错误码:'                         print EOFError                      except:                        print '11060,客户端发送数据错误'                if isHeaveMysql:                    self.updateUserDataToMysql([poid,pos,stageid], askMysqlType.SQL_UpdateMapPoint,createpoint)                else:                    self.insetUserDataToMysql([poid,pos,stageid], askMysqlType.SQL_InsetMapPoint,createpoint)        elif clientobj.handler.cmd == 11059:#删除塔点数据            cgdat = Cmds_pb2.RequestRemoveStagePoint()            cgdat.ParseFromString(clientobj.data)            stageid = cgdat.stageID            pos = cgdat.pos            posid = str(self.account) + str(stageid)            if self.mappoints.has_key(posid):                ptype = self.mappoints[posid][pos]                self.mappoints[posid][pos] = 0                def removePoint(cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseRemoveStagePoint()                    self.resouce.getResourceForProtobuff(cpdat.res, 2)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.len = len(csenddat)                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat() + csenddat                    try:                        cliobj.csocket.send(csenddat)                    except EOFError:                        print '11059,发送数据错误,错误码:'                         print EOFError                      except:                        print '11059,客户端发送数据错误'                self.updateUserDataToMysql([posid,pos,stageid], askMysqlType.SQL_UpdateMapPoint, removePoint)            else:                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_NoheaveStagePoint                handlertmp.com = 0                csenddat = handlertmp.getStructDat()                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11059,发送数据错误,错误码:'                     print EOFError                  except:                    print '11059,客户端发送数据错误'        elif clientobj.handler.cmd == 11027:#签到补签            cgdat = Cmds_pb2.RequestRelogin()            cgdat.ParseFromString(clientobj.data)            loginx = self.userOtherData.loginRewardStats            lasttime = time.localtime(self.lastLoginTime) #上次签到时间            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_mday == 1:#今天是第一天，不用补签                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_NoHeaveRelogin                handlertmp.com = 0                csenddat = handlertmp.getStructDat()                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11059,发送数据错误,错误码:'                     print EOFError                  except:                    print '11059,客户端发送数据错误'                return            elif loctim.tm_mday > 1:                #读取今天之前签到信息                buday = 0                for p in range(31):                    tflog = 1 << p                    if (tflog & loginx) == 0 and p < loctim.tm_mday - 1:                        self.userOtherData.loginRewardStats = loginx | tflog                        buday = p+1                        break                #计算补签消耗                caststr = ''                if self.relogintimes > 10:                    relogintab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',100 + 11)                    caststr = str(relogintab['consume'])                else:                    relogintab = self.userCacheT.getConfigDataWithTableNameAndID('tab_common_times_consume',100+self.relogintimes + 1)                    caststr = str(relogintab['consume'])                casts = self.splitCastGoodsWithOneStrToIntDats(caststr, splitstr = ';')                userheave = self.resouce.getResWithNameOrType(casts[0])                if userheave >= casts[2]:                                               #扣除需要消耗的资源                    self.resouce.setResWithNameOrType(casts[0], userheave - casts[2])                    #补签奖励                    tid = int(loctim.tm_mon * 100 + buday) #补签ID                    print tid,loctim.tm_mday                    logintab = self.userCacheT.getConfigDataWithTableNameAndID('tab_signIn',tid)                    gooddats = self.splitCastGoodsWithOneStrToIntDats(str(logintab['goods_info']), splitstr = ';')                    vipdats = self.splitCastGoodsWithOneStrToIntDats(str(logintab['vip_multiple']), ';')                    def loginbackFunc(insetnid = 0,confids = gooddats,cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseRelogin()                        if insetnid != 0:#奖励为物品或者英雄                            if gooddats[0] == 9:#奖励为英雄                                pass #签到不奖励英雄                            elif self.items.has_key(insetnid):#奖励为道具                                proitem = cpdat.pItems.add()                                self.items[insetnid].getItemDataForProtobuff(proitem)                        self.resouce.getResourceForProtobuff(cpdat.res, confids[0])                        cpdat.loginData = self.userOtherData.loginRewardStats                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.len = len(csenddat)                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11027,签到奖励向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11027,签到奖励向客户端送数据错误'                        return                    if gooddats[0] <= 8:#签到奖励资源                        rcount = gooddats[2]                        if self.userBase.vipLevel >= vipdats[0]:                            rcount = gooddats[2]*vipdats[1]                        restmp = self.resouce.getResWithNameOrType(gooddats[0]) + rcount                        self.resouce.setResWithNameOrType(gooddats[0], restmp)                        self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab) #保存补签次数                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,loginbackFunc)                    elif gooddats[0] == 9:#签到奖励英雄                        pass #签到不奖励英雄                    elif gooddats[0] == 10:#签到送道具                        goodcid = gooddats[1]                        itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                        rcount = gooddats[2]                        if self.userBase.vipLevel >= vipdats[0]:                            rcount = gooddats[2]*vipdats[1]                        itemNetID = 0                        for itx in self.items.keys():                            if self.items[itx].itemCID == goodcid:                                itemNetID = itx                        if itemNetID != 0:                            if self.items[itemNetID].itemNumber >= int(itemtabdat['stackNums']):                                handlertmp = clientobj.handler                                handlertmp.len = 0                                handlertmp.eno = erroflog.Erro_HeaveMoreGoods                                handlertmp.enc = 0                                handlertmp.com = 0                                try:                                    clientobj.csocket.send(handlertmp.getStructDat())                                except EOFError:                                    print '11027,签到客户端发送数据错误,错误码:'                                     print EOFError                                  except:                                    print '11027,签到购买客户端发送数据错误'                                return                            else:                                self.items[itemNetID].itemNumber += rcount   #增加道具数据                                if self.items[itemNetID].itemNumber > int(itemtabdat['stackNums']):                                    self.items[itemNetID].itemNumber = int(itemtabdat['stackNums'])                                def loginItemMysqlBackFunc2(itemNID = itemNetID,cliobj = clientobj):                                    cpsdat = Cmds_pb2.ResponseRelogin()                                    cpdat.loginData = self.userOtherData.loginRewardStats                                    itemtmpx = cpsdat.pItems.add()                                    self.items[itemNID].getItemDataForProtobuff(itemtmpx)                                    print '11027,奖励道具:'                                    print cpsdat                                    csenddat = cpsdat.SerializePartialToString()                                    handlertmp = cliobj.handler                                    handlertmp.len = len(csenddat)                                    handlertmp.enc = 0                                    handlertmp.eno = 0                                    handlertmp.com = 0                                    csenddat = handlertmp.getStructDat() + csenddat                                    try:                                        cliobj.csocket.send(csenddat)                                    except EOFError:                                        print '11027,签到客户端发送数据错误,错误码:'                                         print EOFError                                      except:                                        print '11027,签到购买客户端发送数据错误'                                self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab)  #保存签到时间                                self.updateUserDataToMysql(itemNetID, askMysqlType.SQL_UpdataItems,loginItemMysqlBackFunc2)                        else:                            itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                            self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = int(rcount),itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                            print itemuserid                            def loginItemMysqlFunc(itemNewNIDs,itemuid = itemuserid,cliobj = clientobj):                                if self.itemsNumbers.has_key(itemuid):                                    _cid = self.itemsNumbers.pop(itemuid)                                cpsdat = Cmds_pb2.ResponseRelogin()                                cpdat.loginData = self.userOtherData.loginRewardStats                                itemtmpx = cpsdat.pItems.add()                                self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                                print '11027,签到奖励装备:'                                print cpsdat                                csenddat = cpsdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.len = len(csenddat)                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.com = 0                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                    cliobj.csocket.send(csenddat)                                except EOFError:                                    print '11027,签到奖励道具客户端发送数据错误,错误码:'                                     print EOFError                                  except:                                    print '11027,签到奖励道客户端发送数据错误'                            self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab) #保存签到时间                            self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc)                    elif gooddats[0] == 11:#签到送装备                        goodcid = gooddats[1]                        itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                        itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                        self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                        #扣除消耗资源                        def loginItemMysqlFunc3(itemNewNIDs,itemuid = itemuserid,cliobj = clientobj):                            if self.itemsNumbers.has_key(itemuid):                                _cid = self.itemsNumbers.pop(itemuid)                            cpsdat = Cmds_pb2.ResponseRelogin()                            cpdat.loginData = self.userOtherData.loginRewardStats                            itemtmpx = cpsdat.pItems.add()                            self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                            print '11027,奖励装备:'                            print cpsdat                            csenddat = cpsdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.com = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                cliobj.csocket.send(csenddat)                            except EOFError:                                print '11027,奖励装备客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11027,奖励装备客户端发送数据错误'                        self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab)  #保存签到时间                        self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc3)                else:                                                                   #补签资源不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat()                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11027,发送数据错误,错误码:'                         print EOFError                      except:                        print '11027,客户端发送数据错误'                    return        elif clientobj.handler.cmd == 11020:#英雄技能升级            pass            cgdat = Cmds_pb2.RequestSkillLeveUp()            cgdat.ParseFromString(clientobj.data)            skillnid = cgdat.skillNetID            upcount = cgdat.upCount            if not self.heroSkills.has_key(skillnid):#英雄技能网络ID不存在                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_notHeroSkill                handlertmp.com = 0                csenddat = handlertmp.getStructDat()                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11020,发送数据错误,错误码:'                     print EOFError                  except:                    print '11020,客户端发送数据错误'                return            else:                heroskill = self.heroSkills[skillnid]                skillcid = heroskill.skillCID                endleve = 0                if upcount > 0:                    endleve = heroskill.skillLevel + upcount                elif self.userBase.level > 60:#技能最大等级为60级                    endleve = 60                else:                    endleve = self.userBase.level                if endleve > self.userBase.level:#技能等级不能大于玩家等级                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_skillLimitUserLevel                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat()                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11020,发送数据错误,错误码:'                         print EOFError                      except:                        print '11020,客户端发送数据错误'                    return                startTabID = skillcid*100 + heroskill.skillLevel                endtabid = skillcid*100 + endleve                upcast = 0                upcastType = 0                #这里默认只消耗资源                for td in range(startTabID,endtabid):                    heroskilltab = self.userCacheT.getConfigDataWithTableNameAndID('tab_skill',td)                    casts = self.splitCastGoodsWithOneStrToIntDats(heroskilltab['upgrade_money'], splitstr = ';')                    upcastType = casts[0]                    upcast += casts[2]                heaveres = self.resouce.getResWithNameOrType(upcastType)                if heaveres < upcast:#升级技能资源不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat()                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11020,发送数据错误,错误码:'                         print EOFError                      except:                        print '11020,客户端发送数据错误'                    return                else:                    heaveres -= upcast                    self.resouce.setResWithNameOrType(upcastType, heaveres)                    self.heroSkills[skillnid].skillLevel = endleve                    def skillleveUpCallBackFunc(pSkillnid = skillnid,moneyType = upcastType,cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseSkillLeveUp()                        tmpskill = cpdat.pHeroSkill.add()                        self.heroSkills[pSkillnid].getHeroSkillForProtobuff(tmpskill)                        self.resouce.getResourceForProtobuff(cpdat.res, moneyType)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11020,发送数据错误,错误码:'                             print EOFError                          except:                            print '11020,客户端发送数据错误'                        return                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.updateUserDataToMysql(skillnid, askMysqlType.SQL_UpdataHeroSkill, skillleveUpCallBackFunc)        elif clientobj.handler.cmd == 11029:#熔练            cgdat = Cmds_pb2.RequestEquipSmelting()            cgdat.ParseFromString(clientobj.data)            equip1nid = None            equip2nid = None            equip3nid = None            equip4nid = None            equip5nid = None            equips = []            itemnid = None            for eidx in cgdat.pEquipNetIDs:                print self.items[eidx].itemType                if self.items.has_key(eidx) and self.items[eidx].itemType == 0:                    itemnid = eidx                elif self.items.has_key(eidx) and self.items[eidx].itemType > 0:                    equips.append(eidx)            if len(equips) == 1:                equip1nid = equips[0]            elif len(equips) == 2:                equip1nid = equips[0]                equip2nid = equips[1]            elif len(equips) == 3:                equip1nid = equips[0]                equip2nid = equips[1]                equip3nid = equips[2]            elif len(equips) == 4:                equip1nid = equips[0]                equip2nid = equips[1]                equip3nid = equips[2]                equip4nid = equips[3]            elif len(equips) == 5:                equip1nid = equips[0]                equip2nid = equips[1]                equip3nid = equips[2]                equip4nid = equips[3]                equip5nid = equips[4]            if self.items.has_key(equip1nid) and self.items.has_key(equip2nid) and self.items.has_key(equip3nid) and self.items.has_key(equip4nid) and self.items.has_key(equip5nid) and self.items.has_key(itemnid):                conid1 = self.items[equip1nid].itemCID                conid2 = self.items[equip2nid].itemCID                conid3 = self.items[equip3nid].itemCID                conid4 = self.items[equip4nid].itemCID                conid5 = self.items[equip5nid].itemCID                itemcid = self.items[itemnid].itemCID                tab1 = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',conid1)                tab2 = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',conid2)                tab3 = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',conid3)                tab4 = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',conid4)                tab5 = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',conid5)                itemtab = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',itemcid)                #熔练装备品质平均值                lvQ = (int(tab1['rank']) + int(tab2['rank']) + int(tab3['rank']) + int(tab4['rank']) + int(tab5['rank']))/5                print lvQ,int(itemtab['rank'])                if lvQ != int(tab1['rank']) or lvQ != int(tab2['rank']) or lvQ != int(tab3['rank']) or lvQ != int(tab4['rank']) or lvQ != int(tab5['rank']):                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_equipNotEqu #熔练的装备品质不相同                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat()                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11029,发送数据错误,错误码:'                         print EOFError                      except:                        print '11029,客户端发送数据错误'                    return                elif int(itemtab['rank']) != lvQ + 1:                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_itemLowEquip #熔练图纸品质要比装备品质大1                    handlertmp.com = 0                    csenddat = handlertmp.getStructDat()                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11029,发送数据错误,错误码:'                         print EOFError                      except:                        print '11029,客户端发送数据错误'                    return                else:#计算熔练消耗                    casttab = self.userCacheT.getConfigDataWithTableNameAndID('tab_smelting_consume',int(itemtab['rank'])-1) #                    casts = self.splitCastGoodsWithOneStrToIntDats(str(casttab['consume']), splitstr = ';')                    heavecast = self.resouce.getResWithNameOrType(casts[0])                                        if casts[2] > heavecast:                        handlertmp = clientobj.handler                        handlertmp.len = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_NotEnoughResouce #熔练消耗资源不足                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat()                        try:                            clientobj.csocket.send(csenddat)                        except EOFError:                            print '11029,发送数据错误,错误码:'                             print EOFError                          except:                            print '11029,客户端发送数据错误'                        return                    else:                        #扣除熔练消耗资源                        heavecast -= casts[2]                        self.resouce.setResWithNameOrType(casts[0], heavecast)                        subequipstmp = [equip1nid,equip2nid,equip3nid,equip4nid,equip5nid]                        newequipcid = self.userCacheT.getEquipWithTypeAndRank(int(itemtab['compose']),int(itemtab['rank']))                        itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',newequipcid)                        itemuserid = self.getItemNewIndex(newequipcid)#新道具的临时ID                        self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = newequipcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                        def callmysqlbackFunc(itemNewNIDs,itemuid = itemuserid,subequips = subequipstmp,castitem = itemnid, cliobj = clientobj,moneytype = casts[0]):                            cpdat = Cmds_pb2.ResponseEquipSmelting()#                             if self.itemsNumbers.has_key(itemuid):#                                 _cid = self.itemsNumbers.pop(itemuid)                            itemtmpx = cpdat.pEquips.add()                            self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                            equiptmp1 = cpdat.pEquips.add()                            equip1rem = self.items.pop(subequips[0])                            equip1rem.itemNumber = 0                            equip1rem.getItemDataForProtobuff(equiptmp1)                            equiptmp2 = cpdat.pEquips.add()                            equip2rem = self.items.pop(subequips[1])                            equip2rem.itemNumber = 0                            equip2rem.getItemDataForProtobuff(equiptmp2)                            equiptmp3 = cpdat.pEquips.add()                            equip3rem = self.items.pop(subequips[2])                            equip3rem.itemNumber = 0                            equip3rem.getItemDataForProtobuff(equiptmp3)                            equiptmp4 = cpdat.pEquips.add()                            equip4rem = self.items.pop(subequips[3])                            equip4rem.itemNumber = 0                            equip4rem.getItemDataForProtobuff(equiptmp4)                            equiptmp5 = cpdat.pEquips.add()                            equip5rem = self.items.pop(subequips[4])                            equip5rem.itemNumber = 0                            equip5rem.getItemDataForProtobuff(equiptmp5)                            itemtmp = cpdat.pEquips.add()                            if self.items[castitem].itemNumber == 1:                                itemrem = self.items.pop(castitem)                                itemrem.getItemDataForProtobuff(itemtmp)                            else:                                self.items[castitem].getItemDataForProtobuff(itemtmp)                            self.resouce.getResourceForProtobuff(cpdat.res, moneytype)                            print cpdat                            csenddat = cpdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.com = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                cliobj.csocket.send(csenddat)                            except EOFError:                                print '11029,发送数据错误,错误码:'                                 print EOFError                              except:                                print '11029,客户端发送数据错误'                            return                        self.deleteUserDataFromMysql(equip1nid, askMysqlType.SQL_DeleteItems)                        self.deleteUserDataFromMysql(equip2nid, askMysqlType.SQL_DeleteItems)                        self.deleteUserDataFromMysql(equip3nid, askMysqlType.SQL_DeleteItems)                        self.deleteUserDataFromMysql(equip4nid, askMysqlType.SQL_DeleteItems)                        self.deleteUserDataFromMysql(equip5nid, askMysqlType.SQL_DeleteItems)                        if self.items[itemnid].itemNumber == 1:                            self.items[itemnid].itemNumber = 0                            self.deleteUserDataFromMysql(itemnid, askMysqlType.SQL_DeleteItems)                        else:                            self.items[itemnid].itemNumber -= 1                            self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                        self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,callmysqlbackFunc)            else:                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_itemNetIDErro                handlertmp.com = 0                csenddat = handlertmp.getStructDat()                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11027,发送数据错误,错误码:'                     print EOFError                  except:                    print '11027,客户端发送数据错误'                return        elif clientobj.handler.cmd == 11022:#获取邮件列表            cgdat = Cmds_pb2.RequestEmailInfo()            cgdat.ParseFromString(clientobj.data)            if self.isNewEmail:#有未从数据库中取出的邮件                def whenGetNewEmail(cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseEmailInfo()                    self.Email.getProtobufDataForHeaveEmails(cpdat.pEmails)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                        cliobj.csocket.send(csenddat)                    except EOFError:                        print '11027,发送数据错误,错误码:'                         print EOFError                      except:                        print '11027,客户端发送数据错误'                    return                self.getNewEamilDataFromDB(whenGetNewEmail)            else:                cpdat = Cmds_pb2.ResponseEmailInfo()                self.Email.getProtobufDataForHeaveEmails(cpdat.pEmails)                csenddat = cpdat.SerializePartialToString()                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = 0                handlertmp.len = len(csenddat)                csenddat = handlertmp.getStructDat() + csenddat                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11027,发送数据错误,错误码:'                     print EOFError                  except:                    print '11027,客户端发送数据错误'                return        #发送邮件,邮件发送到给用户管理器,        elif clientobj.handler.cmd == 11023:# //发送邮件:11023# //protobuff请求# message RequestSendEmail# {    #     optional bytes sendName = 1;                //发送邮件用户名#     optional bytes receiveName = 2;                //接收邮件用户名#     optional bytes pText = 3;                    //邮件内容#     optional int32 itemNetIDs = 4;                //用邮件向其他玩家发送道具#     optional int32 HeroNetIDs = 5;                //用邮件向其他玩家发送英雄，此功能可能没有，写数据时可以留空#     optional Resource res = 6;                    //用邮件发送给其他玩家资源#     optional int32 emailType = 7;                //邮件类型2,玩客信息,7.到付邮件（到付邮件在玩家交换物品时使用）8.到付邮件被退回# }# //protobuff响应            #先通过玩家名获取接收玩家的帐号                        cgdat = Cmds_pb2.RequestSendEmail()            cgdat.ParseFromString(clientobj.data)            sendUserName = cgdat.sendName                        def foundUserAccountFunc(data,cgdattmp = cgdat):                print data                self.sendUserEmailToAccount(cgdattmp, data)            self.sreachUserDataFromMysql(sendUserName, askMysqlType.SQL_SelectUserName, foundUserAccountFunc)            # message ResponseSendEmail# {#     optional Resource res = 1;                    //剩余资源信息#     repeated Item pItems = 2;                    //发送后的道具#     repeated Hero pHero1s = 3;                    //发送后的英雄信息#     repeated HeroSkill pHero2s = 4;                //发送后的英雄信息# }            pass        elif clientobj.handler.cmd == 11024:#删除邮件            cgdat = Cmds_pb2.RequestDeleteEmailById()            cgdat.ParseFromString(clientobj.data)            ids = cgdat.emailIDs            def deleEmailFunc(eidtmps = ids,cliobj = clientobj):                cpdat = Cmds_pb2.ResponseDeleteEmailById()                for ei in eidtmps:                    cpdat.pEmails.append(ei)                csenddat = cpdat.SerializePartialToString()                handlertmp = cliobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = 0                handlertmp.len = len(csenddat)                csenddat = handlertmp.getStructDat() + csenddat                try:                    clientobj.csocket.send(csenddat)                except EOFError:                    print '11027,发送数据错误,错误码:'                     print EOFError                  except:                    print '11027,客户端发送数据错误'                return            for di in range(len(ids)):                if di == len(ids) -1:                    self.deleEmailWithIDFromDB(ids[di],deleEmailFunc)                else:                    self.deleEmailWithIDFromDB(ids[di])        elif clientobj.handler.cmd == 11025:#获取邮件中的奖励            cgdat = Cmds_pb2.RequestRewardFromEmail()            cgdat.ParseFromString(clientobj.data)            emailID = cgdat.emailID            def getEmailRewardFunc(emainid = emailID,cliobj = clientobj):                emaildat = self.Email.getEmailData(emainid)                 cpdat = Cmds_pb2.ResponseRewardFromEmail()                emaildat.getEmailRwardProtobuffData(cpdat)                csenddat = cpdat.SerializePartialToString()                handlertmp = cliobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = 0                handlertmp.len = len(csenddat)                csenddat = handlertmp.getStructDat() + csenddat                try:                    cliobj.csocket.send(csenddat)                except EOFError:                    print '11027,发送数据错误,错误码:'                     print EOFError                  except:                    print '11027,客户端发送数据错误'                return            self.updateUserDataToMysql(emailID, askMysqlType.SQL_UpdataEmail, getEmailRewardFunc)        elif clientobj.handler.cmd == 11026:#查看玩家对战战报            pass        elif clientobj.handler.cmd == 11006:#玩家出售道具            cgdat = Cmds_pb2.RequestSellItem()            cgdat.ParseFromString(clientobj.data)            itemnid = cgdat.itemNetID            icount = cgdat.itemNumber            if not self.items.has_key(itemnid):#道具不存在                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_itemNetIDErro                handlertmp.len = 0                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11006,出售道具向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11006,出售道具向客户端送数据错误'                return            itemcid = self.items[itemnid].itemCID            itemconftab = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',itemcid)            sellmoney = int(itemconftab['sell'])#默认出售为铜钱            if icount >= self.items[itemnid].itemNumber:#全部出售,同时删除道具网络ID                sellgetm = sellmoney*(self.items[itemnid].itemNumber)                self.resouce.copper += sellgetm                def sellItemFunc(itemnidf = itemnid):                    cpdat = Cmds_pb2.ResponseSellItem()                    self.resouce.getResourceForProtobuff(cpdat.res, 2)                    titem = self.items.pop(itemnidf)                    titem.itemNumber = 0                    proitem = cpdat.itemmsg.add()                    titem.getItemDataForProtobuff(proitem)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11006,出售道具向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11006,出售道具向客户端送数据错误'                    return                self.deleteUserDataFromMysql(itemnid, askMysqlType.SQL_DeleteItems)                self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, sellItemFunc)            else:#部分出售                sellgetm = sellmoney*(self.items[itemnid].itemNumber - icount)                self.resouce.copper += sellgetm                self.items[itemnid].itemNumber -= icount                def sellItemFunc2(itemnidf = itemnid):                    cpdat = Cmds_pb2.ResponseSellItem()                    self.resouce.getResourceForProtobuff(cpdat.res, 2)                    proitem = cpdat.itemmsg.add()                    self.items[itemnid].getItemDataForProtobuff(proitem)                    print cpdat                    csenddat = cpdat.SerializePartialToString()                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11006,出售道具向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11006,出售道具向客户端送数据错误'                    return                self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems)                self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, sellItemFunc2)        elif clientobj.handler.cmd == 11028:#玩家签到            cpdat = Cmds_pb2.RequestLoginReward()            #签到客户端不用发送数据            lasttime = time.localtime(self.lastLoginTime)            loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0            if loctim.tm_mday - lasttime.tm_mday >= 1:#玩家当天未签到，可签到                if loctim.tm_mday == 1:#今天是当月的第一天                    self.userOtherData.loginRewardStats = 1                else:                    tmpstat = self.userOtherData.loginRewardStats                    tmpbin = 1 << loctim.tm_mday                    self.userOtherData.loginRewardStats = tmpstat | tmpbin                tabid = loctim.tm_mon*100 + loctim.tm_mday                self.lastLoginTime = int(time.time())                loginconftab = self.userCacheT.getConfigDataWithTableNameAndID('tab_signIn',tabid)                gooddats = self.splitCastGoodsWithOneStrToIntDats(str(loginconftab['goods_info']), splitstr = ';')                print gooddats                vipdats = self.splitCastGoodsWithOneStrToIntDats(str(loginconftab['vip_multiple']), ';')                def loginbackFunc(insetnid = 0,confids = gooddats,cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseLoginReward()                    cpdat.loginTimes = self.userOtherData.loginRewardStats                    if insetnid != 0:#奖励为物品或者英雄                        if gooddats[0] == 9:#奖励为英雄                            prohero = cpdat.pHeros.add()                            self.heros[insetnid].getHeroDataForProtoBuff(prohero)                        elif self.items.has_key(insetnid):#奖励为道具                            proitem = cpdat.pItems.add()                            self.items[insetnid].getItemDataForProtobuff(proitem)                    else:#奖励为资源                        self.resouce.getResourceForProtobuff(cpdat.res, confids[0])                    print cpdat                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11028,签到奖励向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11028,签到奖励向客户端送数据错误'                    return                if gooddats[0] <= 8:#签到奖励资源                    rcount = gooddats[2]                    if self.userBase.vipLevel >= vipdats[0]:                        rcount = gooddats[2]*vipdats[1]                    restmp = self.resouce.getResWithNameOrType(gooddats[0]) + rcount                    self.resouce.setResWithNameOrType(gooddats[0], restmp)                    self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab) #保存签到时间                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,loginbackFunc)                elif gooddats[0] == 9:#签到奖励英雄                    goodcid = gooddats[1]                    hcids,skills = self._insetNewHeroWithID([gooddats[1]])                    def insetMysqlBackFunc2(gherocid = goodcid,gskillids = skills,cliobj = clientobj):                        cpsdat = Cmds_pb2.ResponseLoginReward()                        cpsdat.loginTimes = self.userOtherData.loginRewardStats                        pherotmp = cpsdat.pHeros.add()                        self.heros[self.heroConfigs[gherocid]].getHeroDataForProtoBuff(pherotmp)                        pheroskills = cpsdat.pheroSkills.add()                        skillNetID = self.heros[self.heroConfigs[gherocid]].skillNetID                        self.heroSkills[skillNetID].getHeroSkillForProtobuff(pheroskills)                        print '11028,签到奖励武将:'                        print cpsdat                        csenddat = cpsdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11028,签到奖励武将客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11028,签到奖励武将客户端发送数据错误'                    self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab) #保存签到时间                    self.insetUserDataToMysql(hcids, askMysqlType.SQL_InsetHeros)                    self.insetUserDataToMysql(skills, askMysqlType.SQL_InsetHeroSkill,insetMysqlBackFunc2)                elif gooddats[0] == 10:#签到送道具                    goodcid = gooddats[1]                    itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                    rcount = gooddats[2]                    if self.userBase.vipLevel >= vipdats[0]:                        rcount = gooddats[2]*vipdats[1]                    itemNetID = 0                    for itx in self.items.keys():                        if self.items[itx].itemCID == goodcid:                            itemNetID = itx                    if itemNetID != 0:                        if self.items[itemNetID].itemNumber >= int(itemtabdat['stackNums']):                            handlertmp = clientobj.handler                            handlertmp.len = 0                            handlertmp.eno = erroflog.Erro_HeaveMoreGoods                            handlertmp.enc = 0                            handlertmp.com = 0                            try:                                clientobj.csocket.send(handlertmp.getStructDat())                            except EOFError:                                print '11028,签到客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11028,签到购买客户端发送数据错误'                        else:                                                        self.items[itemNetID].itemNumber += rcount   #增加道具数据                            if self.items[itemNetID].itemNumber > int(itemtabdat['stackNums']):                                self.items[itemNetID].itemNumber = int(itemtabdat['stackNums'])                            def loginItemMysqlBackFunc2(itemNID = itemNetID,cliobj = clientobj):                                cpsdat = Cmds_pb2.ResponseLoginReward()                                cpsdat.loginTimes = self.userOtherData.loginRewardStats                                itemtmpx = cpsdat.pItems.add()                                self.items[itemNID].getItemDataForProtobuff(itemtmpx)                                print '11028,奖励道具:'                                print cpsdat                                csenddat = cpsdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.len = len(csenddat)                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.com = 0                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                    cliobj.csocket.send(csenddat)                                except EOFError:                                    print '11028,签到客户端发送数据错误,错误码:'                                     print EOFError                                  except:                                    print '11028,签到购买客户端发送数据错误'                            self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab)  #保存签到时间                            self.updateUserDataToMysql(itemNetID, askMysqlType.SQL_UpdataItems,loginItemMysqlBackFunc2)                    else:                        itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                        self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = int(rcount),itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                        print itemuserid                        def loginItemMysqlFunc(itemNewNIDs,itemuid = itemuserid,cliobj = clientobj):                            if self.itemsNumbers.has_key(itemuid):                                _cid = self.itemsNumbers.pop(itemuid)                            cpsdat = Cmds_pb2.ResponseLoginReward()                            cpsdat.loginTimes = self.userOtherData.loginRewardStats                            itemtmpx = cpsdat.pItems.add()                            self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                            print '11028,签到奖励装备:'                            print cpsdat                            csenddat = cpsdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.com = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                cliobj.csocket.send(csenddat)                            except EOFError:                                print '11028,签到奖励道具客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11028,签到奖励道客户端发送数据错误'                        self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab) #保存签到时间                        self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc)                elif gooddats[0] == 11:#签到送装备                    goodcid = gooddats[1]                    itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                    itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                    self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                    #扣除消耗资源                    def loginItemMysqlFunc3(itemNewNIDs,itemuid = itemuserid,cliobj = clientobj):                        if self.itemsNumbers.has_key(itemuid):                            _cid = self.itemsNumbers.pop(itemuid)                        cpsdat = Cmds_pb2.ResponseLoginReward()                        cpsdat.loginTimes = self.userOtherData.loginRewardStats                        itemtmpx = cpsdat.pItems.add()                        self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                        print '11028,奖励装备:'                        print cpsdat                        csenddat = cpsdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11028,奖励装备客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11028,奖励装备客户端发送数据错误'                    self.updateUserDataToMysql('otherdata', askMysqlType.SQL_UpdataAccountTab)  #保存签到时间                    self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc3)            else:#今天已经签过到                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_todayIsLogined                handlertmp.len = 0                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11006,出售道具向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11006,出售道具向客户端送数据错误'                return        elif clientobj.handler.cmd == 11009:#请求武将升级            cdat = Cmds_pb2.RequestHeroUpgrade()            cdat.ParseFromString(clientobj.data)            cHeroNetID = cdat.heroNetID            cHeroLeveType = cdat.leveType            tmpHero = self.heros[cHeroNetID]            hconfID = tmpHero.heroCID            hleve = tmpHero.heroLevel            hstar = tmpHero.heroStar            htabconf = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroAttr',hconfID*10 + hstar)            upcastPrice = 0          #升级消耗铜钱资源            if self.userBase.level <= hleve:                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_toUserLeveMax                handlertmp.len = 0                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11009,武将升级向客户端送数据错误,错误码:'                     print EOFError                  except:                      print '11009,武将升级向客户端送数据错误'                return            if cHeroLeveType > 0: #使用计数升，非一键升级                #计算需要升星次数                baseleve = hleve                endlevel = cHeroLeveType + baseleve                leveupcount = 0                if endlevel > int(htabconf['levelMax']):                    endlevel = int(htabconf['levelMax'])                    leveupcount = (int(htabconf['levelMax']) - baseleve)                    upcastPrice = leveupcount * int(htabconf['depletePrice'])                else:                    upcastPrice = int(htabconf['depletePrice'])*cHeroLeveType #消耗铜钱                    leveupcount = cHeroLeveType                if self.resouce.copper < upcastPrice:                    #升级资源不足                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.len = 0                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11009,武将升级向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11009,武将升级向客户端送数据错误'                else:                    self.heros[cHeroNetID].heroLevel = endlevel                    self.resouce.copper -= upcastPrice                    def updata11009(hNetID = cHeroNetID,cliObj = clientobj):                        cpdat = Cmds_pb2.ResponseHeroUpgrade()                        herotmpx = cpdat.pHero.add()                        self.heros[hNetID].getHeroDataForProtoBuff(herotmpx)                        self.resouce.getResourceForProtobuff(cpdat.res, 2)                        print 'uphero11009:'                        print cpdat                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliObj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.len = len(csenddat)                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliObj.csocket.send(csenddat)                        except EOFError:                              print '11009,武将升级向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11009,武将升级向客户端送数据错误'                    print 'save mysql'                    tasks = self.task.heroLeveUp(cHeroNetID, leveupcount) #获取英雄升级任务                    if len(tasks) > 0:                        pushtask = Cmds_pb2.PushTaskList()                        for x in tasks:                            pushtask.pTaskIDs.append(x)                        csenddatpush = pushtask.SerializeToString()                        handlertmp = T_MSGHEAD_T()                        handlertmp.com = 2       #com的第1位表示是否压缩，com的第二位表示是否推送                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.cmd = 13001   #任务推送接口                        handlertmp.len = len(csenddatpush)                        csenddatpush = handlertmp.getStructDat() + csenddatpush                        try:                              clientobj.csocket.send(csenddatpush)                        except EOFError:                              print '11009升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11009升级返回客户端数据错误'                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.updateUserDataToMysql(cHeroNetID, askMysqlType.SQL_UpdataHeros, updata11009)            else:#玩家使用一键升级                canleveup = 0                htabconftmp = htabconf              #当前星级配置需求配置信息                copperheav = self.resouce.copper    #基础铜钱资源                castcopper = 0                leveupcount = int(htabconf['levelMax']) - hleve                nextstarcapper = leveupcount * int(htabconf['depletePrice'])                canleveup = int((copperheav/int(htabconftmp['depletePrice']))+hleve)                if canleveup > int(htabconf['levelMax']):                    castcopper = nextstarcapper                    canleveup = int(htabconf['levelMax'])                else:                    castcopper += int(htabconf['depletePrice'])*canleveup                    leveupcount = canleveup                                if canleveup > self.userBase.level:                    canleveup = self.userBase.level                    castcopper = (canleveup - hleve) * int(htabconf['depletePrice'])                if self.resouce.copper < castcopper:                    #升级一次的资源都不够                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.len = 0                    csenddat = handlertmp.getStructDat()                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11009,武将升级向客户端送数据错误,错误码:'                         print EOFError                      except:                              print '11009,武将升级向客户端送数据错误'                else:                    self.heros[cHeroNetID].heroLevel = canleveup                    self.resouce.copper -= castcopper                    def updata11009oneKey(hNetID = cHeroNetID,cliObj = clientobj):                        cpdat = Cmds_pb2.ResponseHeroUpgrade()                        herotmpx = cpdat.pHero.add()                        self.heros[hNetID].getHeroDataForProtoBuff(herotmpx)                        self.resouce.getResourceForProtobuff(cpdat.res, 2)                        print 'uphero11009:'                        print cpdat                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliObj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.len = len(csenddat)                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliObj.csocket.send(csenddat)                        except EOFError:                              print '11009,武将升级向客户端送数据错误,错误码:'                             print EOFError                          except:                              print '11009,武将升级向客户端送数据错误'                    tasks = self.task.heroLeveUp(cHeroNetID, leveupcount) #获取英雄升级任务                    if len(tasks) > 0:                        pushtask = Cmds_pb2.PushTaskList()                        for x in tasks:                                pushtask.pTaskIDs.append(x)                        csenddat = pushtask.SerializePartialToString()                        handlertmp = T_MSGHEAD_T()                        handlertmp.com = 2       #com的第1位表示是否压缩，com的第二位表示是否为推送                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.cmd = 13001      #任务推送接口                        handlertmp.len(csenddat)                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11070装备升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11070装备升级返回客户端数据错误'                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.updateUserDataToMysql(cHeroNetID, askMysqlType.SQL_UpdataHeros, updata11009oneKey)        elif clientobj.handler.cmd == 11010:#招莫武将            cdat = Cmds_pb2.RequestRandomRecruit()            cdat.ParseFromString(clientobj.data)            rectype = cdat.recruitType            timestype = cdat.timesType            if rectype == 0:#友情抽取英雄,每次消耗100点友情值，友情互送每次10点                cast = 100*timestype                if self.resouce.friendpoint < cast:#友情值不足                    print '玩家友情点不足'                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.eno = erroflog.Erro_NoFriendPoint                    handlertmp.enc = 0                    handlertmp.com = 0                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11010,招武将向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11010,招武将向客户端送数据错误'                    return                else:                    self.resouce.friendpoint -= cast            elif rectype == 1:#88元宝抽取英雄                cast = 88*timestype                if self.resouce.acer < cast: #元宝不足                    print '玩家元宝不足'                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao                    handlertmp.enc = 0                    handlertmp.com = 0                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11010,招武将向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11010,招武将向客户端送数据错误'                    return                else:                    self.resouce.acer -= cast            elif rectype == 2:#188元宝抽取英雄                cast = 188*timestype                if self.resouce.acer < cast: #元宝不足                    print '玩家元宝不足'                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.eno = erroflog.Erro_NoYuanBao                    handlertmp.enc = 0                    handlertmp.com = 0                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11010,招武将向客户端送数据错误,错误码:'                         print EOFError                      except:                          print '11010,招武将向客户端送数据错误'                    return                else:                    self.resouce.acer -= cast            heroks = self.userCacheT.getHeroWithTypeAndCount(rectype,timestype)            #[{'heroId': 42021.0, 'interval': 0.0, 'extractId': 21.0, 'weight': 100.0, 'soul': 10.0}, {'heroId': 42012.0, 'interval': 0.0, 'extractId': 12.0, 'weight': 100.0, 'soul': 10.0}, {'heroId': 42020.0, 'interval': 0.0, 'extractId': 20.0, 'weight': 100.0, 'soul': 10.0}, {'heroId': 42014.0, 'interval': 0.0, 'extractId': 14.0, 'weight': 100.0, 'soul': 10.0}, {'heroId': 42019.0, 'interval': 0.0, 'extractId': 19.0, 'weight': 100.0, 'soul': 10.0}, {'heroId': 42004.0, 'interval': 0.0, 'extractId': 4.0, 'weight': 100.0, 'soul': 10.0}]            newhs = []            newhskills = []            hsamehs = []            print heroks            for h in heroks:                hidtmp = int(h['heroId'])                if hidtmp in newhs:                    self.resouce.soul += int(h['soul'])                    hsamehs.append(hidtmp)                else:                    if self.heroConfigs.has_key(hidtmp):                        self.resouce.soul += int(h['soul'])                        hsamehs.append(hidtmp)                    else:                        newhs.append(hidtmp)            cpdat = Cmds_pb2.ResponseRandomRecruit()            if len(newhs) > 0 or len(hsamehs) > 0 :                cpdat.res.friendpoint = self.resouce.friendpoint                cpdat.res.acer = self.resouce.acer          #抽取武将消耗元宝                cpdat.res.soul = self.resouce.soul          #重复武将转换为将魂                _hids,newhskills = self._insetNewHeroWithID(newhs) #将新英雄加入用户数据，同时返回英雄的新技能ID                def insetMysqlBackFunc(sameheros = hsamehs,gherocids = newhs,gskillids = newhskills,sdata = cpdat,backclientobj = clientobj):                    for h in gherocids:                        herotmp = cpdat.pHeroes.add()                        skilltmp = cpdat.pheroSKills.add()                        self.heros[self.heroConfigs[h]].getHeroDataForProtoBuff(herotmp)                        self.heroSkills[self.heros[self.heroConfigs[h]].skillNetID].getHeroSkillForProtobuff(skilltmp)                    if len(sameheros) > 0:                        while len(sameheros) > 0:                            shtmp = sameheros.pop()                            sherotmp = cpdat.sameHeros.add()                            sherotmp.confID = shtmp                            sherotmp.moreCount = 1                            for shx in sameheros:                                if shx == shtmp:                                    sherotmp.moreCount += 1                    print '抽取武将11010:'                    print cpdat                    senddat = cpdat.SerializePartialToString()                    handlertmp = clientobj.handler                    handlertmp.len = len(senddat)                    handlertmp.com = 0                    senddat = handlertmp.getStructDat() + senddat                     try:                          backclientobj.csocket.send(senddat)                    except EOFError:                          print '11010抽取武将返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11010抽取武将返回客户端数据错误'                if len(newhs) > 0:                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    def insetHeroBackFunc(callback = insetMysqlBackFunc):#先保存武将信息，得到武将网络ID后再保存武将技能信息                        self.insetUserDataToMysql(newhskills, askMysqlType.SQL_InsetHeroSkill,callback)  #保存所有武将技能,并在保存成功后向客户端返回结果                    self.insetUserDataToMysql(newhs, askMysqlType.SQL_InsetHeros,insetHeroBackFunc)     #保存武将信息                else:#抽取的所有武将都重复，只用更新数据库资源数据                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,insetMysqlBackFunc)            else:                cpdat.res.friendpoint = self.resouce.friendpoint                cpdat.res.acer = self.resouce.acer          #抽取武将消耗元宝                cpdat.res.soul = self.resouce.soul          #重复武将转换为将魂                senddat = cpdat.SerializePartialToString()                handlertmp = clientobj.handler                handlertmp.len = len(senddat)                handlertmp.com = 0                senddat = handlertmp.getStructDat() + senddat                 try:                      clientobj.csocket.send(senddat)                except EOFError:                      print '11010抽取武将返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11010抽取武将返回客户端数据错误'            #mysql在数据库中保存英雄和技能        elif clientobj.handler.cmd == 11068:#获取商城列表            _cgdat = Cmds_pb2.RequestGetUserShopInfo()            nowtime = int(time.time())            if self.shopgoods and nowtime - self.lastShopRefreshTime  >= 24*60*60:                #24小时刷新一次                self.shopgoods = self.userCacheT.getStoreGoodsForUser()                self.lastShopRefreshTime = nowtime            else:                self.shopgoods = self.userCacheT.getStoreGoodsForUser()                print 'goods:\n'                print self.shopgoods                cpdat = Cmds_pb2.ResponseGetUserShopInfo()                for g in self.shopgoods:                    tmpstore = cpdat.storeItems.add()                    tmpstore.itemStoreID = g                    if self.BuyedItems.has_key(g):                        tmpstore.buyTimes = self.BuyedItems[g]                    else:                        tmpstore.buyTimes = 0                cpdat.refreshTime = self.lastShopRefreshTime                self.lastShopRefreshTime = int(time.time())                csenddat = cpdat.SerializePartialToString()                handlertmp = clientobj.handler                handlertmp.len = len(csenddat)                handlertmp.enc = 0                handlertmp.eno = 0                handlertmp.com = 0                csenddat = handlertmp.getStructDat() + csenddat                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11010抽取武将返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11010抽取武将返回客户端数据错误'        elif clientobj.handler.cmd == 11069:#商城够买道具            cgdat = Cmds_pb2.RequestBuyItem()            cgdat.ParseFromString(clientobj.data)            storecid = cgdat.pItemCID            itemcount = cgdat.number            print cgdat            itemtab = self.userCacheT.getConfigDataWithTableNameAndID('tab_store',storecid)            itemmsg = itemtab['goods'].split(';')            goodtype = int(itemmsg[0])          #商城物品类型            goodcid = int(itemmsg[1])           #商城物品配置ID            goodshowcount = int(itemmsg[2])     #商城显示数量            buymoneystr = itemtab['consume'].split(';')            goodcasttype = int(buymoneystr[0])  #花费货币类型            dazhe = float(itemtab['sale'])/1000.0                        needViplv = int(itemtab['required_vip'])            maxbuytimes = int(itemtab['limit_player_num'])            if self.userBase.vipLevel < needViplv:#vip等级不足                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_NotEnoughVipLeve                handlertmp.enc = 0                handlertmp.com = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11069,商城购买客户端发送数据错误,错误码:'                     print EOFError                  except:                      print '11069,商城购买客户端发送数据错误'                return            if self.BuyedItems.has_key(storecid) and self.BuyedItems[storecid] >= maxbuytimes:#已达到最大够买数量                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_HeaveMaxBuyCount                handlertmp.enc = 0                handlertmp.com = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11069,商城购买客户端发送数据错误,错误码:'                     print EOFError                  except:                      print '11069,商城购买客户端发送数据错误'                return            goodcast = int(float(buymoneystr[2])*itemcount*dazhe)      #购买花费金额            heavecast = self.resouce.getResWithNameOrType(goodcasttype)            if heavecast < goodcast:#用户购买所需资源不足                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_NotEnoughResouce                handlertmp.enc = 0                handlertmp.com = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11069,商城购买客户端发送数据错误,错误码:'                     print EOFError                  except:                      print '11069,商城购买客户端发送数据错误'            else:                itemtabdat = None                if goodtype == 10:#道具                    itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                    itemNetID = 0                    for itx in self.items.keys():                        if self.items[itx].itemCID == goodcid:                            itemNetID = itx                    if itemNetID != 0:                        if self.items[itemNetID].itemNumber >= int(itemtabdat['stackNums']):                            handlertmp = clientobj.handler                            handlertmp.len = 0                            handlertmp.eno = erroflog.Erro_HeaveMoreGoods                            handlertmp.enc = 0                            handlertmp.com = 0                            try:                                clientobj.csocket.send(handlertmp.getStructDat())                            except EOFError:                                print '11069,商城购买客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11069,商城购买客户端发送数据错误'                        else:                            self.items[itemNetID].itemNumber += (itemcount*goodshowcount)   #增加道具数据                            if self.items[itemNetID].itemNumber > int(itemtabdat['stackNums']):                                self.items[itemNetID].itemNumber = int(itemtabdat['stackNums'])                            heavecast -= goodcast                            self.resouce.setResWithNameOrType(goodcasttype, heavecast)      #扣除消耗资源                            def buyitemMysqlBackFunc(itemNID = itemNetID,moneytype = goodcasttype,cliobj = clientobj):                                cpsdat = Cmds_pb2.ResponseBuyItem()                                itemtmpx = cpsdat.pItems.add()                                self.items[itemNID].getItemDataForProtobuff(itemtmpx)                                self.resouce.getResourceForProtobuff(cpsdat.res, moneytype)                                print '10069,购买道具1:'                                print cpsdat                                csenddat = cpsdat.SerializePartialToString()                                handlertmp = cliobj.handler                                handlertmp.len = len(csenddat)                                handlertmp.enc = 0                                handlertmp.eno = 0                                handlertmp.com = 0                                csenddat = handlertmp.getStructDat() + csenddat                                try:                                    cliobj.csocket.send(csenddat)                                except EOFError:                                    print '11069,商城购买客户端发送数据错误,错误码:'                                     print EOFError                                  except:                                    print '11069,商城购买客户端发送数据错误'                            if maxbuytimes > 0:                                if self.BuyedItems.has_key(storecid):                                    self.BuyedItems[storecid] += 1                                else:                                    self.BuyedItems[storecid] =  1                                self.updateUserDataToMysql('', askMysqlType.SQL_UpdataBuyItemTimes)                            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                            self.updateUserDataToMysql(itemNetID, askMysqlType.SQL_UpdataItems,buyitemMysqlBackFunc)                    else:                        itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                        self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = (itemcount*goodshowcount),itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                        #扣除消耗资源                        heavecast -= goodcast                        print itemuserid                        self.resouce.setResWithNameOrType(goodcasttype, heavecast)                        def buyitemMysqlFunc(itemNewNIDs,itemuid = itemuserid,moneytype = goodcasttype,cliobj = clientobj):                            if self.itemsNumbers.has_key(itemuid):                                _cid = self.itemsNumbers.pop(itemuid)                            cpsdat = Cmds_pb2.ResponseBuyItem()                            itemtmpx = cpsdat.pItems.add()                            self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                            self.resouce.getResourceForProtobuff(cpsdat.res, moneytype)                            print '10069,购买道具2:'                            print cpsdat                            csenddat = cpsdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.com = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                cliobj.csocket.send(csenddat)                            except EOFError:                                print '11069,商城购买客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11069,商城购买客户端发送数据错误'                        if maxbuytimes > 0:                            if self.BuyedItems.has_key(storecid):                                self.BuyedItems[storecid] += 1                            else:                                self.BuyedItems[storecid] =  1                            self.updateUserDataToMysql('', askMysqlType.SQL_UpdataBuyItemTimes)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                        self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,buyitemMysqlFunc)                elif goodtype == 11:#装备                    itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                    itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                    self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                    #扣除消耗资源                    heavecast -= goodcast                    self.resouce.setResWithNameOrType(goodcasttype, heavecast)                    def buyitemMysqlFunc(itemNewNIDs,itemuid = itemuserid,moneytype = goodcasttype,cliobj = clientobj):                        if self.itemsNumbers.has_key(itemuid):                            _cid = self.itemsNumbers.pop(itemuid)                        cpsdat = Cmds_pb2.ResponseBuyItem()                        itemtmpx = cpsdat.pItems.add()                        self.items[itemNewNIDs[0]].getItemDataForProtobuff(itemtmpx)                        self.resouce.getResourceForProtobuff(cpsdat.res, moneytype)                        print '10069,购买道具2:'                        print cpsdat                        csenddat = cpsdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11069,商城购买客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11069,商城购买客户端发送数据错误'                    if maxbuytimes > 0:                        if self.BuyedItems.has_key(storecid):                            self.BuyedItems[storecid] += 1                        else:                            self.BuyedItems[storecid] =  1                        self.updateUserDataToMysql('', askMysqlType.SQL_UpdataBuyItemTimes)                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,buyitemMysqlFunc)                elif goodtype == 9:#购买英雄                    itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroInfo',goodcid)                    if self.heroConfigs.has_key(goodcid):#已有当前武将不能再购买                        handlertmp = clientobj.handler                        handlertmp.len = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_UserHadTheHero                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat()                        print '玩家已有当前要购买武将'                        try:                            clientobj.csocket.send(csenddat)                        except EOFError:                            print '11069,商城购买客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11069,商城购买客户端发送数据错误'                    else:                        _hids,newhskills = self._insetNewHeroWithID([goodcid]) #将新英雄加入用户数据，同时返回英雄的新技能ID                        def insetMysqlBackFunc(gherocid = goodcid,gskillids = newhskills,moneytype = goodcasttype,cliobj = clientobj):                            cpsdat = Cmds_pb2.ResponseBuyItem()                            pherotmp = cpsdat.pheros.add()                            self.heros[self.heroConfigs[gherocid]].getHeroDataForProtoBuff(pherotmp)                            pheroskills = cpsdat.pheroSkills.add()#                            self.heroSkills[self.heros[self.heroConfigs[gherocid]].skillNetID].getHeroSkillForProtobuff(pheroskills)                            self.resouce.getResourceForProtobuff(cpsdat.res, moneytype)                            print '10069,购买武将:'                            print cpsdat                            csenddat = cpsdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.com = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                cliobj.csocket.send(csenddat)                            except EOFError:                                print '11069,商城购买客户端发送数据错误,错误码:'                                 print EOFError                              except:                                print '11069,商城购买客户端发送数据错误'                        if maxbuytimes > 0:                            if self.BuyedItems.has_key(storecid):                                self.BuyedItems[storecid] += 1                            else:                                self.BuyedItems[storecid] =  1                            self.updateUserDataToMysql('', askMysqlType.SQL_UpdataBuyItemTimes)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                        self.insetUserDataToMysql([goodcid], askMysqlType.SQL_InsetHeros)     #保存武将信息                        self.insetUserDataToMysql(newhskills, askMysqlType.SQL_InsetHeroSkill,insetMysqlBackFunc)  #保存所有武将技能,并在保存成功后向客户端返回结果                if itemtabdat == None:#购买的是资源                    #扣除消耗资源                    heavecast -= goodcast                    self.resouce.setResWithNameOrType(goodcasttype, heavecast)                    addres = self.resouce.getResWithNameOrType(goodtype)                    addres += itemcount*goodshowcount                    self.resouce.setResWithNameOrType(goodtype, addres)                    def addresMysqlFucn(addmoneyType = goodtype,castmoneytype = goodcasttype):                        cpdat = Cmds_pb2.ResponseBuyItem()                        self.resouce.getResourceForProtobuff(cpdat.res, addmoneyType)                        self.resouce.getResourceForProtobuff(cpdat.res, castmoneytype)                        print '11069,商城购买资源:\n'                        print cpdat                        csenddat = cpdat.SerializePartialToString()                        handlertmp = clientobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11010抽取武将返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11010抽取武将返回客户端数据错误'                    if maxbuytimes > 0:                        if self.BuyedItems.has_key(storecid):                            self.BuyedItems[storecid] += 1                        else:                            self.BuyedItems[storecid] =  1                        self.updateUserDataToMysql('', askMysqlType.SQL_UpdataBuyItemTimes)                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,addresMysqlFucn)        elif clientobj.handler.cmd == 11072:#获取任务信息,返回任务列表            cgdat = Cmds_pb2.RequestGetTask()            cpdat = Cmds_pb2.ResponseGetTask()            self.task.getTaskList(cpdat.pTasks)            csenddat = cpdat.SerializePartialToString()            handlertmp = clientobj.handler            handlertmp.len = len(csenddat)            handlertmp.enc = 0            handlertmp.eno = 0            handlertmp.com = 0            csenddat = handlertmp.getStructDat() + csenddat            try:                  clientobj.csocket.send(csenddat)            except EOFError:                  print '11072,返回客户端数据错误,错误情况:'                 print EOFError              except:                  print '11072,返回客户端数据错误'        elif clientobj.handler.cmd == 11030:#领取任务奖励            cgdat = Cmds_pb2.RequestTaskReward()            cgdat.ParseFromString(clientobj.data)            taskcid = cgdat.taskCID[0]            tasktype,reslout = self.task.getTaskReward(taskcid)            if reslout:                tasktab = self.userCacheT.getConfigDataWithTableNameAndID('tab_task',taskcid)                rewardstr = tasktab['award_goods']                rewars = self.splitCastGoodsWithTowStrToIntDats(rewardstr, splitstr1 = '|', splitstr2 = ';')                taskRewarRes = []                insetItemtmps = []                updataItemtmps = []                #taskRewarHero = []                for rex in rewars:                    if rex[0] <= 8:#奖励资源                        heaveres = self.resouce.getResWithNameOrType(rex[0])                        heaveres += rex[2]                        self.resouce.setResWithNameOrType(rex[0], heaveres)                        taskRewarRes.append(rex[0])                    elif rex[0] == 9:#奖励英雄                        pass                    elif rex[0] == 10:#任务奖励道具                        goodcid = rex[1]                        itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                        rcount = rex[2]                        itemNetID = 0                        for itx in self.items.keys():                            if self.items[itx].itemCID == goodcid:                                itemNetID = itx                        if itemNetID != 0:                            if self.items[itemNetID].itemNumber >= int(itemtabdat['stackNums']):                                handlertmp = clientobj.handler                                handlertmp.len = 0                                handlertmp.eno = erroflog.Erro_HeaveMoreGoods                                handlertmp.enc = 0                                handlertmp.com = 0                                try:                                    clientobj.csocket.send(handlertmp.getStructDat())                                except EOFError:                                    print '11030,发送数据错误,错误码:'                                     print EOFError                                  except:                                    print '11030,发送数据错误'                                return                            else:                                self.items[itemNetID].itemNumber += rcount   #增加道具数据                                insetItemtmps.append(itemNetID)                                if self.items[itemNetID].itemNumber > int(itemtabdat['stackNums']):                                    self.items[itemNetID].itemNumber = int(itemtabdat['stackNums'])                        else:                            itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                            self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = int(rcount),itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                            insetItemtmps.append(itemuserid)                    elif rex[0] == 11:#签到送装备                        goodcid = rex[1]                        itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                        itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                        self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                        insetItemtmps.append(itemuserid)                if taskRewarRes and not insetItemtmps and not updataItemtmps:#任务只奖励资源                    def rewarCallbackFunc(ptaskRewarRes = taskRewarRes,cliobj = clientobj,taskcidn = taskcid):                        cpdat = Cmds_pb2.ResponseTaskReward()                        self.task.getTaskToProtbuf(cpdat.pTask,taskcidn)                        if ptaskRewarRes:                            for rx in ptaskRewarRes:                                self.resouce.getResourceForProtobuff(cpdat.res, rx)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              cliobj.csocket.send(csenddat)                        except EOFError:                              print '11030,返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11030,返回客户端数据错误'                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,rewarCallbackFunc)                elif insetItemtmps:                    def rewarCallbackFunc2(itemnids,pinsetItemtmps = insetItemtmps,pupdataItemtmps = updataItemtmps,ptaskRewarRes = taskRewarRes,cliobj = clientobj,taskcidn = taskcid):                        for itemuid in pinsetItemtmps:                            if self.itemsNumbers.has_key(itemuid):                                _cid = self.itemsNumbers.pop(itemuid)                        cpdat = Cmds_pb2.ResponseTaskReward()                        self.task.getTaskToProtbuf(cpdat.pTask,taskcidn)                        if ptaskRewarRes:                            for rx in ptaskRewarRes:                                self.resouce.getResourceForProtobuff(cpdat.res, rx)                        if pupdataItemtmps:                            for ix in pupdataItemtmps:                                itemtmp = cpdat.pItems.add()                                self.items[ix].getItemDataForProtobuff(itemtmp)                        for idx in itemnids:                            itemtmp = cpdat.pItems.add()                            self.items[idx].getItemDataForProtobuff(itemtmp)                                                print '11030,任务领取奖励:'                        print cpdat                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11030,签到奖励道具客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11030,签到奖励道客户端发送数据错误'                    for ax in updataItemtmps:                        self.updateUserDataToMysql(ax, askMysqlType.SQL_UpdataItems)                    if taskRewarRes:                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.insetUserDataToMysql(insetItemtmps, askMysqlType.SQL_InsetItems, rewarCallbackFunc2)                else:                    def rewarCallbackFunc3(pupdataItemtmps = updataItemtmps,ptaskRewarRes = taskRewarRes,cliobj = clientobj,taskcidn = taskcid):                        cpdat = Cmds_pb2.ResponseTaskReward()                        self.task.getTaskToProtbuf(cpdat.pTask,taskcidn)                        if ptaskRewarRes:                            for rx in ptaskRewarRes:                                self.resouce.getResourceForProtobuff(cpdat.res, rx)                        if pupdataItemtmps:                            for ix in pupdataItemtmps:                                itemtmp = cpdat.pItems.add()                                self.items[ix].getItemDataForProtobuff(itemtmp)                        print '11030,任务领取奖励:'                        print cpdat                        csenddat = cpdat.SerializePartialToString()                        handlertmp = cliobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.com = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                            cliobj.csocket.send(csenddat)                        except EOFError:                            print '11030,签到奖励道具客户端发送数据错误,错误码:'                             print EOFError                          except:                            print '11030,签到奖励道客户端发送数据错误'                                        if taskRewarRes:                        for ax in updataItemtmps:                            self.updateUserDataToMysql(ax, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,rewarCallbackFunc3)                    elif updataItemtmps:                        for ai in range(len(updataItemtmps)):                            ax = updataItemtmps[ai]                            if ai < len(updataItemtmps) - 1:                                self.updateUserDataToMysql(ax, askMysqlType.SQL_UpdataItems)                            else:                                self.updateUserDataToMysql(ax, askMysqlType.SQL_UpdataItems,rewarCallbackFunc3)            else:                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_taskNotComplete  #玩家任务未完成                handlertmp.com = 0                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11030,返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11030,返回客户端数据错误'# // 56,领取任务奖励:11030# //protobuff请求# message RequestTaskReward# {    #     repeated int32 taskCID = 1;                 //任务ID# }# //protobuff响应# message ResponseTaskReward# {#     repeated Task pTask = 1;                     //任务详情#     repeated Item pItems = 2;                    //获得道具#     repeated Hero pHeros = 3;                    //获得英雄#     optional Resource res = 4;                    //获得资源# }        elif clientobj.handler.cmd == 11070:#装备升级            cgdat = Cmds_pb2.RequestEquipLevelUp()            cgdat.ParseFromString(clientobj.data)            equipnid = cgdat.pItemNetID            leveuptype = cgdat.leveupType            if not self.items.has_key(equipnid):                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_NoItemNetID #装备不存在,网络ID错误                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11070装备升级返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11070装备升级返回客户端数据错误'                return            equipArrcID = int(self.items[equipnid].itemCID)*10+int(self.items[equipnid].itemStar)            equipArrtab = self.userCacheT.getConfigDataWithTableNameAndID('tab_equipAttr',equipArrcID)            if leveuptype == -1:#一键升级装备                equiphero = self.items[equipnid].itemUsedID                canleveup = 0                castres = 0                if equiphero > 0 and int(equipArrtab['maxLevel']) > self.heros[equiphero].heroLevel and self.heros[equiphero].heroLevel > self.items[equipnid].itemLevel:                    canleveup =  self.heros[equiphero].heroLevel - self.items[equipnid].itemLevel                    castres = int(equipArrtab['depleteTongqian'])*canleveup #消耗铜钱                elif equiphero > 0 and int(equipArrtab['maxLevel']) <= self.heros[equiphero].heroLevel and int(equipArrtab['maxLevel']) > self.items[equipnid].itemLevel:                    canleveup = int(equipArrtab['maxLevel']) - self.items[equipnid].itemLevel                    castres = int(equipArrtab['depleteTongqian'])*canleveup #消耗铜钱                elif equiphero <= 0:                    canleveup = int(equipArrtab['maxLevel']) - self.items[equipnid].itemLevel                    castres = int(equipArrtab['depleteTongqian'])*canleveup #消耗铜钱                if canleveup > 0 and castres > 0:                    if castres <= self.resouce.copper:                        self.resouce.setResWithNameOrType(2, (self.resouce.copper-castres))#扣除资源                        self.items[equipnid].itemLevel += canleveup                        def equipleveupfunc(itemnid = equipnid,cliobj = clientobj):                            cpdat = Cmds_pb2.ResponseEquipLevelUp()                            tmpitemx = cpdat.pItem.add()                            self.items[itemnid].getItemDataForProtobuff(tmpitemx)                            self.resouce.getResourceForProtobuff(cpdat.res,2)                            csenddat = cpdat.SerializePartialToString()                            handlertmp = clientobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.com = 0                            handlertmp.enc = 0                            handlertmp.eno = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  clientobj.csocket.send(csenddat)                            except EOFError:                                  print '11070装备升级返回客户端数据错误,错误情况:'                                 print EOFError                              except:                                  print '11070装备升级返回客户端数据错误'                        tasks = self.task.equipLeveUp(equipnid, canleveup) #获取装备升级任务                        if len(tasks) > 0:                            pushtask = Cmds_pb2.PushTaskList()                            for x in tasks:                                pushtask.pTaskIDs.append(x)                            csenddat = pushtask.SerializePartialToString()                            handlertmp = T_MSGHEAD_T()                            handlertmp.com = 2       #1位表示压缩，com的第二位表示是否为推送                            handlertmp.enc = 0                            handlertmp.eno = 0                            handlertmp.cmd = 13001      #任务推送接口                                                        handlertmp.len(csenddat)                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  clientobj.csocket.send(csenddat)                            except EOFError:                                  print '11070装备升级返回客户端数据错误,错误情况:'                                 print EOFError                              except:                                  print '11070装备升级返回客户端数据错误'                        self.updateUserDataToMysql('', askMysqlType.SQL_UpdataUserTask)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                        self.updateUserDataToMysql(equipnid, askMysqlType.SQL_UpdataItems, equipleveupfunc)                        return                    else:#资源不足                        handlertmp = clientobj.handler                        handlertmp.len = 0                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = erroflog.Erro_NotEnoughResouce #资源不足                        try:                              clientobj.csocket.send(handlertmp.getStructDat())                        except EOFError:                              print '11070装备升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11070装备升级返回客户端数据错误'                        return                else:#已达当前最大等级                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_hadMaxEquipLeve #装备已达当前星级的最大等级                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11070装备升级返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11070装备升级返回客户端数据错误'                    return            else:                levecount = leveuptype                canleveup = int(equipArrtab['maxLevel']) - self.items[equipnid].itemLevel                if canleveup > levecount:                    canleveup = levecount                castres = int(equipArrtab['depleteTongqian'])*canleveup #消耗铜钱                if castres <= self.resouce.copper:                    self.resouce.setResWithNameOrType(2, (self.resouce.copper-castres))#扣除资源                    self.items[equipnid].itemLevel += canleveup                    def equipleveupfunc(itemnid = equipnid,cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseEquipLevelUp()                        tmpitemx = cpdat.pItem.add()                        self.items[itemnid].getItemDataForProtobuff(tmpitemx)                        self.resouce.getResourceForProtobuff(cpdat.res,2)                        csenddat = cpdat.SerializePartialToString()                        handlertmp = clientobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11070装备升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11070装备升级返回客户端数据错误'                    tasks = self.task.equipLeveUp(equipnid, canleveup) #获取装备升级任务                    if len(tasks) > 0:                        pushtask = Cmds_pb2.PushTaskList()                        for x in tasks:                            pushtask.pTaskIDs.append(x)                        csenddat = pushtask.SerializePartialToString()                        handlertmp = T_MSGHEAD_T()                        handlertmp.com = 2       #1位表示压缩，com的第二位表示是否为推送                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.cmd = 13001      #任务推送接口                        handlertmp.len(csenddat)                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11070装备升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11070装备升级返回客户端数据错误'                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.updateUserDataToMysql(equipnid, askMysqlType.SQL_UpdataItems, equipleveupfunc)                    return                else:#资源不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce #资源不足                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11070装备升级返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11070装备升级返回客户端数据错误'                    return        elif clientobj.handler.cmd == 11071:#装备升星            cgdat = Cmds_pb2.RequestEquipStarUp()            cgdat.ParseFromString(clientobj.data)            equipnid = cgdat.pItemNetID            casttype = cgdat.castType            print 'casttype===',casttype            equipArrcID = int(self.items[equipnid].itemCID)*10+int(self.items[equipnid].itemStar)            equipArrtab = self.userCacheT.getConfigDataWithTableNameAndID('tab_equipAttr',equipArrcID)            equipInfotab = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',int(self.items[equipnid].itemCID))            userleveuptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_expup',self.userBase.level)            heronid = self.items[equipnid].itemUsedID            if not self.items.has_key(equipnid):#装备不存在                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_NoItemNetID #装备不存在,网络ID错误                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11071装备升星返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11071装备升星返回客户端数据错误'                return            elif self.items[equipnid].itemStar >= int(equipInfotab['equipStarMax']):                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_hadMaxEquipStar #装备已达最大星级                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11071装备升星返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11071装备升星返回客户端数据错误'                return            elif self.items[equipnid].itemStar >= int(userleveuptab['maxEquipStar']):#装备已达玩家等级限制的最大星级                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_userLeveLimit #玩家等级限制升星                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11071装备升星返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11071装备升星返回客户端数据错误'                return#             elif heronid > 0 and  self.heros[heronid].heroStar < self.items[equipnid].itemStar:#                 handlertmp = clientobj.handler#                 handlertmp.len = 0#                 handlertmp.com = 0#                 handlertmp.enc = 0#                 handlertmp.eno = erroflog.Erro_heroStarLimit #英雄星级限制升星#                 try:  #                     clientobj.csocket.send(handlertmp.getStructDat())#                 except EOFError:  #                     print '11071装备升星返回客户端数据错误,错误情况:' #                     print EOFError  #                 except:  #                     print '11071装备升星返回客户端数据错误'#                 return            else:                castres = str(equipArrtab['depleteSold'])                castdatas = self.splitCastGoodsWithTowStrToIntDats(castres)                isResEnough,castgoods = self.testCastGoods(castdatas)                print isResEnough,castgoods                if isResEnough:#装备升星所需资源足够,并且已扣除相应资源                    self.items[equipnid].itemStar += 1                    self.items[equipnid].itemLevel = 1                    def equipleveupfunc(itemnid = equipnid,needgoods = castgoods,cliobj = clientobj):                        cpdat = Cmds_pb2.ResponseEquipLevelUp()                        tmpitemx = cpdat.pItem.add()                        self.items[itemnid].getItemDataForProtobuff(tmpitemx)                        for good in needgoods:                            if good[0] == 10 or good[0] == 11:                                tmpitex = cpdat.pItem.add()                                self.items[good[1]].getItemDataForProtobuff(tmpitex)                            elif good[0] <= 8:                                self.resouce.getResourceForProtobuff(cpdat.res,good[0])                        csenddat = cpdat.SerializePartialToString()                        handlertmp = clientobj.handler                        handlertmp.len = len(csenddat)                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        csenddat = handlertmp.getStructDat() + csenddat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11070装备升级返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11070装备升级返回客户端数据错误'                    for good in castgoods:                        if good[0] == 10 or good[0] == 11:#更新升星需要道具                            self.updateUserDataToMysql(good[1], askMysqlType.SQL_UpdataItems)                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                    self.updateUserDataToMysql(equipnid, askMysqlType.SQL_UpdataItems, equipleveupfunc)                    return                else:#资源或者道具不足                    handlertmp = clientobj.handler                    handlertmp.len = 0                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce #升星需要资源不足                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11071装备升星返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11071装备升星返回客户端数据错误'                    return        elif clientobj.handler.cmd == 11013:#武将升星            cgdata = Cmds_pb2.RequestHeroStarUp()            cgdata.ParseFromString(clientobj.data)            print cgdata            hNetID = cgdata.heroNetID            herotmp = self.heros[hNetID]            heroConfig = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroInfo',herotmp.heroCID)            heroAttr = self.userCacheT.getConfigDataWithTableNameAndID('tab_heroAttr',herotmp.heroCID*10 + herotmp.heroStar)            userleveuptab = self.userCacheT.getConfigDataWithTableNameAndID('tab_expup',self.userBase.level)            if self.heros[hNetID].heroStar >= int(userleveuptab['maxHeroStar']):                #英雄升星受到玩家等级限制                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_userLeveLimit #武将升星受玩家等级限制                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11013武将升星返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11013武将升星返回客户端数据错误'                return            elif herotmp.heroStar < int(heroConfig['starMax']):                castdatlist = None                castgoods = []                isResEnough = False                if str(heroAttr['depleteSoul']) != 'null':                    castdatlist = self.splitCastGoodsWithTowStrToIntDats(str(heroAttr['depleteSoul']))                if castdatlist:                    isResEnough,castgoods = self.testCastGoods(castdatlist)                if isResEnough and castgoods:                    if self.heros.has_key(hNetID):                        self.heros[hNetID].heroStar +=1                        self.heros[hNetID].heroLevel = 1                        def upHeroStarMySQLBackFunc(heroNetID = hNetID,castitems = castgoods,cliobj = clientobj):                            cspdat = Cmds_pb2.ResponseHeroStarUp()                            herotmpx = cspdat.pHero.add()                            self.heros[heroNetID].getHeroDataForProtoBuff(herotmpx)                            for good in castitems:                                if good[0] == 10 or good[0] == 11:#道具和装备更新                                    itemtmpx = cspdat.pItems.add()                                    self.items[good[1]].getItemDataForProtobuff(itemtmpx)                                elif good[0] <= 8:                                    self.resouce.getResourceForProtobuff(cspdat.res, good[0])                            print '11013,武将升星成功：'                            print cspdat                            csenddat = cspdat.SerializePartialToString()                            handlertmp = cliobj.handler                            handlertmp.len = len(csenddat)                            handlertmp.enc = 0                            handlertmp.com = 0                            handlertmp.eno = 0                            csenddat = handlertmp.getStructDat() + csenddat                            try:                                  cliobj.csocket.send(csenddat)                            except EOFError:                                  print '11013武将升星返回客户端数据错误,错误情况:'                                 print EOFError                              except:                                  print '11013武将升星返回客户端数据错误'                        for good in castgoods:                            if good[0] == 10 or good[0] == 11:#道具和装备更新                                self.updateUserDataToMysql(good[1], askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)                        self.updateUserDataToMysql(hNetID, askMysqlType.SQL_UpdataHeros, upHeroStarMySQLBackFunc)                else:                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.len = 0                    print '错误：将魂不足'                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11013武将升星返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11013武将升星返回客户端数据错误'                                else:                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_HadMaxHeroStar                handlertmp.len = 0                print '武将已达最大星级'                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11013武将升星返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11013武将升星返回客户端数据错误'        elif clientobj.handler.cmd == 11061:#保存守城武将            cgdat = Cmds_pb2.RequestSaveCityHeros()            cgdat.ParseFromString(clientobj.data)            heronids = cgdat.pheroNetIDs            tmpheros = self.userOutHeros            self.userOutHeros = []            for hid in heronids:                self.userOutHeros.append(hid)            if len(self.userOutHeros) < 3:                while len(self.userOutHeros) < 3:                    self.userOutHeros.append(0)            elif len(self.userOutHeros) > 3:                self.userOutHeros = tmpheros                #客户端数据错误                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_clientDataErro #客户端数据错误                handlertmp.len = 0                print '客户端数据错误'                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11061保存守城武返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11061保存守城武将返回客户端数据错误'                return            def updataStageHeros(errobacks = tmpheros):                cpdat = Cmds_pb2.ResponseSaveCityHeros()                csenddat = cpdat.SerializePartialToString()                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = 0                handlertmp.len = len(csenddat)                csenddat = handlertmp.getStructDat() + csenddat                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11061保存守城武将返回客户端数据错误,错误情况:'                     print EOFError                      self.userOutHeros = errobacks #恢复错误                except:                      print '11061保存守城武将返回客户端数据错误'                    self.userOutHeros = errobacks #恢复错误            self.updateUserDataToMysql('', askMysqlType.SQL_UpdataCityHeros,updataStageHeros)        elif clientobj.handler.cmd == 11065:#战斗开始            cgdat = Cmds_pb2.RequestStageBattleBegin()            cgdat.ParseFromString(clientobj.data)            fightings = cgdat.pHeros      #所有出战英雄战力            self.nowStageHurdle = cgdat.stageID         #关卡id            self.nowStageStartTime = int(time.time())   #关卡战斗开始时间            isAskStagePoint = cgdat.isAskPoint            erroheros = []            tmpheros = self.userStageHeros            self.userStageHeros = []            for fi in fightings:                self.userStageHeros.append(fi.heroNetID)                if fi.heroNetID > 0 and (not self.heros.has_key(fi.heroNetID)):                    erroheros.append(fi.heroNetID)                elif fi.heroNetID > 0 and self.heros[fi.heroNetID].fighting != fi.fighting:                    erroheros.append(fi.heroNetID)            if len(erroheros) > 0 or len(self.userStageHeros) != 9:                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_warHeroFightingErro #武将战力值错误                handlertmp.len = 0                csenddat = handlertmp.getStructDat()                try:                      clientobj.csocket.send(csenddat)                except EOFError:                      print '11065关卡战斗开始返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11065关卡战斗开始返回客户端数据错误'                return            stagetab = self.userCacheT.getConfigDataWithTableNameAndID('tab_pointInfo',self.nowStageHurdle) #关卡数据            casthp = int(stagetab['hp'])            if self.resouce.forage >= casthp:                stagenid = str(self.account) + str(self.nowStageHurdle)                def updataStageHeros(errobacks = tmpheros,isaskpoint = isAskStagePoint,stageNID = stagenid):                    cpdat = Cmds_pb2.ResponseStageBattleBegin()                    self.resouce.getResourceForProtobuff(cpdat.res, 5)                    if isaskpoint and self.mappoints.has_key(stageNID):                        for pt in range(len(self.mappoints[stageNID])):                            stagepos = cpdat.stagepos.add()                            stagepos.pType = self.mappoints[stageNID][pt]                            stagepos.pos = pt                    csenddat = cpdat.SerializePartialToString()                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          clientobj.csocket.send(csenddat)                    except EOFError:                          print '11065关卡战斗开始返回客户端数据错误,错误情况:'                         print EOFError                        self.userStageHeros = errobacks #恢复错误                    except:                          print '11062保存关卡出战武将返回客户端数据错误'                        self.userStageHeros = errobacks #恢复错误                self.sreachUserDataFromMysql(stagenid, askMysqlType.SQL_SelectMapPoint)                self.updateUserDataToMysql('', askMysqlType.SQL_UpdataWarHeros,updataStageHeros)            else:#玩家粮草资源不足                def updataStageHeros(errobacks = tmpheros,cliobj = clientobj):                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_NotEnoughResouce                    handlertmp.len = 0                    csenddat = handlertmp.getStructDat()                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11065关卡战斗开始返回客户端数据错误,错误情况:'                         print EOFError                        self.userStageHeros = errobacks #恢复错误                    except:                          print '11062保存关卡出战武将返回客户端数据错误'                        self.userStageHeros = errobacks #恢复错误                self.updateUserDataToMysql('', askMysqlType.SQL_UpdataWarHeros,updataStageHeros)        elif clientobj.handler.cmd == 11066:#战斗结束            cgdat = Cmds_pb2.RequestStageBattleEnd()            cgdat.ParseFromString(clientobj.data)            stageID = cgdat.stage                       #关卡id            _stageCount = cgdat.enemy                   #波次            resultIsWin = bool(cgdat.resultIsWin)       #关卡战斗结果            if int(time.time()) - self.nowStageStartTime >= 20:#通关时间应该大于最短通关时间                pass            if resultIsWin:#战斗胜利                stagetab = self.userCacheT.getConfigDataWithTableNameAndID('tab_pointInfo',stageID) #关卡数据                casthp = int(stagetab['hp'])                getcopper = int(stagetab['money'])                self.resouce.forage -= casthp                dropID = int(stagetab['dropId'])                if int(stagetab['type']) == 1:#普通难度                    self.stageHurdle1 = stageID                       #简单难度打通关卡号                elif int(stagetab['type']) == 2:#困难难度                    self.stageHurdle2 = stageID                       #普通难度打通关卡号                elif int(stagetab['type']) == 3:#深渊难度                    self.stageHurdle3 = stageID                       #困难难度打通关卡号                droptabtmps = []#保存调落ID                for di in range(100):                    droptab = self.userCacheT.getConfigDataWithTableNameAndID('',dropID*10 + di)                    if droptab:                        droptabtmps.append(droptab)                    else:                        break                goodstrs = ''                for tabtmp in droptabtmps:                    isFirstDrop = int(tabtmp['point_once'])                    if isFirstDrop  > 0 and self.stageHurdle1 >= stageID:#非首次通关,但物品只在首次掉落                        continue                    elif self.getPercentResult(int(tabtmp['prob'])):#首次通关,或者非首次通关，但物品可掉落,并且在掉落机率下物品掉落                        if goodstrs != '':                            goodstrs += '|' + str(tabtmp['goods'])                        else:                            goodstrs += str(tabtmp['goods'])                goods = []                if goodstrs != '':                    goods = self.splitCastGoodsWithTowStrToIntDats(goodstrs, splitstr1 = '|', splitstr2 = ';')                    #返回结果是                    def werendFunc(rewardgoods):                        cpdat = Cmds_pb2.ResponseStageBattleEnd()                        self.resouce.getResourceForProtobuff(cpdat.res, 5)#扣除消耗粮草数据                        for gi in range(len(rewardgoods)):                            rewardgood = rewardgoods[gi]                            if rewardgood[0] <= 8:#战斗奖励资源                                self.resouce.getResourceForProtobuff(cpdat.res, rewardgood[0])                            elif rewardgood[0] == 9 and self.heros.has_key(rewardgood[1]) and self.heroSkills.has_key(rewardgood[2]):#战斗奖励英雄                                htomtmp = cpdat.pHeros.add()                                heroskilltmp = cpdat.pHeroSkills.add()                                self.heros[rewardgood[1]].getHeroDataForProtoBuff(htomtmp)                                self.heroSkills[rewardgood[2]].getHeroSkillForProtobuff(heroskilltmp)                            elif rewardgood[0] == 10 and self.items.has_key(rewardgood[1]):#奖励道具                                itemtmpx = cpdat.pItems.add()                                self.items[rewardgood[1]].getItemDataForProtobuff(itemtmpx)                            elif rewardgood[0] == 11 and self.items.has_key(rewardgood[1]):#奖励装备                                itemtmpx = cpdat.pItems.add()                                self.items[rewardgood[1]].getItemDataForProtobuff(itemtmpx)                        csendat = cpdat.SerializePartialToString()                        handlertmp = clientobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.len = len(csendat)                        csendat = handlertmp.getStructDat() + csendat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11066关卡战斗结束返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11066关卡战斗结束返回客户端数据错误'                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)#扣除粮草消耗                    self.updateUserDataToMysql('stage', askMysqlType.SQL_UpdataAccountTab)#更新通关关卡数据                    self.rewardUserGoods(goods, werendFunc) #在数据库以及玩家数据中添加奖励物品                else:                    #返回结果是                    def werendFunc():                        cpdat = Cmds_pb2.ResponseStageBattleEnd()                        self.resouce.getResourceForProtobuff(cpdat.res, 5)#扣除消耗粮草数据                        csendat = cpdat.SerializePartialToString()                        handlertmp = clientobj.handler                        handlertmp.com = 0                        handlertmp.enc = 0                        handlertmp.eno = 0                        handlertmp.len = len(csendat)                        csendat = handlertmp.getStructDat() + csendat                        try:                              clientobj.csocket.send(csenddat)                        except EOFError:                              print '11066关卡战斗结束返回客户端数据错误,错误情况:'                             print EOFError                          except:                              print '11066关卡战斗结束返回客户端数据错误'                    self.updateUserDataToMysql('stage', askMysqlType.SQL_UpdataAccountTab)#更新通关关卡数据                    self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, werendFunc)            else:#战斗失败                stagetab = self.userCacheT.getConfigDataWithTableNameAndID('tab_pointInfo',stageID) #关卡数据                casthp = int(stagetab['hp'])                getcopper = int(stagetab['money'])                self.resouce.copper += getcopper                self.resouce.forage -= casthp                #返回结果是                def werendFunc():                    cpdat = Cmds_pb2.ResponseStageBattleEnd()                    self.resouce.getResourceForProtobuff(cpdat.res, 5)#消耗粮草数据                    self.resouce.getResourceForProtobuff(cpdat.res, 2)#铜钱奖励                    csendat = cpdat.SerializePartialToString()                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csendat)                    csendat = handlertmp.getStructDat() + csendat                    try:                        clientobj.csocket.send(csenddat)                    except EOFError:                        print '11066关卡战斗结束返回客户端数据错误,错误情况:'                         print EOFError                      except:                        print '11066关卡战斗结束返回客户端数据错误'                self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab, werendFunc)        elif clientobj.handler.cmd == 11051:#武将换装            pass            cgdat = Cmds_pb2.RequestChangeEquip()            cgdat.ParseFromString(clientobj.data)            heronid = cgdat.heroNetID            itemnids = cgdat.itemNetIDs            print itemnids            ptype = cgdat.ptype            itemnid = itemnids[0]            if ptype == 1 and self.items.has_key(itemnid) and self.heros.has_key(heronid):#穿装以及换装                olditemnid = 0                for ik in self.items.keys():                    if self.items[ik].itemUsedID == heronid and self.items[ik].itemType == self.items[itemnid].itemType:                        olditemnid = ik                oldhero = self.items[itemnid].itemUsedID                if self.items[itemnid].itemStar > self.heros[heronid].heroStar or self.items[itemnid].itemLevel > self.heros[heronid].heroLevel:                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_HeroLimitEquip       #装备受武将等级星级限制                    handlertmp.len = 0                    print '武将已达最大星级'                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11013武将升星返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11013武将升星返回客户端数据错误'                    return                self.items[itemnid].itemUsedID = heronid                def updataItemForHeroFunc(pitemnid = itemnid,polditemnid = olditemnid,oldheronid = oldhero,cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseChangeEquip()                    itemcsx = cpdat.pItems.add()                    self.items[pitemnid].getItemDataForProtobuff(itemcsx)                    if polditemnid > 0:                        itemcsx2 = cpdat.pItems.add()                        self.items[polditemnid].getItemDataForProtobuff(itemcsx2)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11051武将穿装返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11051武将穿装返回客户端数据错误'                print oldhero                if olditemnid > 0 and oldhero > 0:                    if self.items[itemnid].itemStar <= self.heros[oldhero].heroStar or self.items[itemnid].itemLevel <= self.heros[oldhero].heroLevel:#武将原来身上有装备                        print olditemnid                        self.items[olditemnid].itemUsedID = oldhero #两个武将交换装备                        self.updateUserDataToMysql(olditemnid, askMysqlType.SQL_UpdataItems)                        self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)                elif olditemnid > 0:                    self.items[olditemnid].itemUsedID = 0 #武将身上原来装备卸下                    self.updateUserDataToMysql(olditemnid, askMysqlType.SQL_UpdataItems)                    self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)                else:                    self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)            elif ptype == 2:#卸装                self.items[itemnid].itemUsedID = 0                def updataItemForHeroFunc(pitemnid = itemnid,cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseChangeEquip()                    itemcsx = cpdat.pItems.add()                    self.items[pitemnid].getItemDataForProtobuff(itemcsx)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11051武将穿装返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11051武将穿装返回客户端数据错误'                self.updateUserDataToMysql(itemnid, askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)            elif ptype == 4:#一键卸装                itemnidtmps = itemnids  #卸下的装备网络ids                for ik in itemnidtmps:                    if self.items[ik].itemUsedID == heronid:                        self.items[ik].itemUsedID = 0                def updataItemForHeroFunc(pitemnids = itemnidtmps,cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseChangeEquip()                    for idx in pitemnids:                        itemcsx = cpdat.pItems.add()                        self.items[idx].getItemDataForProtobuff(itemcsx)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11051一键卸装返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11051一键卸装返回客户端数据错误'                for x in range(len(itemnidtmps)):                    if x == len(itemnidtmps) -1:                        self.updateUserDataToMysql(itemnidtmps[x], askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)                    else:                        self.updateUserDataToMysql(itemnidtmps[x], askMysqlType.SQL_UpdataItems)            elif ptype == 3:#一键穿装                itemnidtmps = itemnids  #要穿上的装备网络ids                erroitemnid = []                for idx in itemnidtmps:                    if self.items[idx].itemUsedID <= 0:                        if self.items[itemnid].itemLevel <= self.heros[heronid].heroLevel:                            self.items[idx].itemUsedID = heronid                        else:                            erroitemnid.append(idx)                if len(erroitemnid) > 0:#有装备等级或者星级大于武将的                    for eid in erroitemnid:                        itemnidtmps.remove(eid)                if len(itemnidtmps) < 1:                    handlertmp = clientobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = erroflog.Erro_HeroLimitEquip       #装备受武将等级星级限制,之后没有可穿戴的装备                    handlertmp.len = 0                    print '武将已达最大星级'                    try:                          clientobj.csocket.send(handlertmp.getStructDat())                    except EOFError:                          print '11013武将升星返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11013武将升星返回客户端数据错误'                    return                def updataItemForHeroFunc(pitemnids = itemnidtmps,cliobj = clientobj):                    cpdat = Cmds_pb2.ResponseChangeEquip()                    for idx in pitemnids:                        itemcsx = cpdat.pItems.add()                        self.items[idx].getItemDataForProtobuff(itemcsx)                    csenddat = cpdat.SerializePartialToString()                    handlertmp = cliobj.handler                    handlertmp.com = 0                    handlertmp.enc = 0                    handlertmp.eno = 0                    handlertmp.len = len(csenddat)                    csenddat = handlertmp.getStructDat() + csenddat                    try:                          cliobj.csocket.send(csenddat)                    except EOFError:                          print '11051一键穿装返回客户端数据错误,错误情况:'                         print EOFError                      except:                          print '11051一键穿装返回客户端数据错误'                for x in range(len(itemnidtmps)):                    if x == len(itemnidtmps) - 1:                        self.updateUserDataToMysql(itemnidtmps[x], askMysqlType.SQL_UpdataItems,updataItemForHeroFunc)                    else:                        self.updateUserDataToMysql(itemnidtmps[x], askMysqlType.SQL_UpdataItems)            else:#装备或武将不存在                handlertmp = clientobj.handler                handlertmp.com = 0                handlertmp.enc = 0                handlertmp.eno = erroflog.Erro_NoHeaveHeroOrItem #装备或武将不存在                handlertmp.len = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11051武将穿装返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11051武将穿装返回客户端数据错误'        elif clientobj.handler.cmd == 11120:#教场升级            cpdat = Cmds_pb2.RequestLevelBatman()            cpdat.ParseFromString(clientobj.data)            bcid = cpdat.batmanCId            soliderOldData = self.userCacheT.getConfigDataWithTableNameAndID('tab_batmanAttr',bcid)            casttype = int(soliderOldData['depleteType'])            castres = int(soliderOldData['depleteNum'])            oldres = self.resouce.getResWithNameOrType(casttype)            if oldres < castres:#升级所需资源不足                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_NotEnoughResouce #升级所需资源不足                handlertmp.enc = 0                handlertmp.com = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11120教场升经返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11120教场升经返回客户端数据错误'                return            oldres = oldres - castres            oldtype = int(soliderOldData['type'])            if oldtype == 1 and self.batmanInfo.dao == bcid:                self.batmanInfo.dao = int(soliderOldData['nextLevelId'])            elif oldtype == 2 and self.batmanInfo.qiang == bcid:                self.batmanInfo.qiang = int(soliderOldData['nextLevelId'])            elif oldtype == 3 and self.batmanInfo.chui == bcid:                self.batmanInfo.chui = int(soliderOldData['nextLevelId'])            elif oldtype == 4 and self.batmanInfo.gong == bcid:                self.batmanInfo.gong = int(soliderOldData['nextLevelId'])            elif oldtype == 5 and self.batmanInfo.ceshi == bcid:                self.batmanInfo.ceshi = int(soliderOldData['nextLevelId'])            elif oldtype == 6 and self.batmanInfo.nvbing == bcid:                self.batmanInfo.nvbing = int(soliderOldData['nextLevelId'])            else:                handlertmp = clientobj.handler                handlertmp.len = 0                handlertmp.eno = erroflog.Erro_BatmanIdUnEqu #校场客户端校场id与服务器不一致                handlertmp.enc = 0                handlertmp.com = 0                try:                      clientobj.csocket.send(handlertmp.getStructDat())                except EOFError:                      print '11120教场升经返回客户端数据错误,错误情况:'                     print EOFError                  except:                      print '11120教场升经返回客户端数据错误'                return            cspdat = Cmds_pb2.ResponseLevelBatman()            self.batmanInfo.getBatmanInfoForProtobuff(cspdat.batmanInfo)            self.resouce.setResWithNameOrType(casttype, oldres)             #扣除升级所需资源消耗            self.resouce.getResourceForProtobuff(cspdat.res,casttype)            print 'back11120:\n'            print cspdat            csenddata = cspdat.SerializePartialToString()            handlertmp = clientobj.handler            handlertmp.len = len(csenddata)            handlertmp.eno = 0            handlertmp.enc = 0            handlertmp.com = 0            csenddata = handlertmp.getStructDat() + csenddata            try:                  clientobj.csocket.send(csenddata)            except EOFError:                  print '向客户端发送校场升级成功出错,错误情况:'                 print EOFError              except:                  print '向客户端发送校场升级成功出错'            self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab)            self.updateUserDataToMysql(oldtype, askMysqlType.SQL_UpdataBatman)                    else:            handlertmp = clientobj.handler            handlertmp.len = 0            handlertmp.eno = erroflog.Erro_NoServerApi #错误码接口不存在            handlertmp.enc = 0            handlertmp.com = 0            try:                  clientobj.csocket.send(handlertmp.getStructDat())            except EOFError:                  print '向客户端发送校场升级成功出错,错误情况:'                 print EOFError              except:                  print '向客户端发送校场升级成功出错'                def getUserDataToClientWithString11002(self):        userdat = Cmds_pb2.ResponseUserInfo()        for h in self.heros.keys():            herotmp = userdat.pheros.add()            self.heros[h].getHeroDataForProtoBuff(herotmp)        for ite in self.items.keys():            itemtmp = userdat.pItems.add()            self.items[ite].getItemDataForProtobuff(itemtmp)        for sk in self.heroSkills.keys():            hskilltmp = userdat.pSkills.add()            self.heroSkills[sk].getHeroSkillForProtobuff(hskilltmp)        for buf in self.userBuffs.keys():            bufftmp = userdat.pBuffs.add()            self.userBuffs[buf].getUserBuffForProtobuff(bufftmp)        for x in self.activityIds:            userdat.activityIds.append(x)        for b in self.batmanInfo.getBatmanInfoForList():            userdat.batmanInfo.batmanCId.append(b)        for hw in self.userStageHeros:            userdat.pWarHeros.append(hw)        for ho in self.userOutHeros:            userdat.pCityHeros.append(ho)        userdat.pWarStageID.append(self.stageHurdle1)        userdat.pWarStageID.append(self.stageHurdle2)        userdat.pWarStageID.append(self.stageHurdle3)        self.userBase.getUserBaseDataForProtobuff(userdat.userData)        self.resouce.getResourceForProtobuff(userdat.res)        self.userOtherData.getUserOtherDataForProtobuff(userdat.otherData)        userdat.otherData.ReloginTimes = self.relogintimes        userdat.otherData.rechargeValue = self.rechargeValue        lasttime = time.localtime(self.userTimes.lastBuyCopperTime) #上次签到时间        loctim = time.localtime() #loctim.tm_year=2015, loctim.tm_mon=8, loctim.tm_mday=2, loctim.tm_hour=12, loctim.tm_min=16, loctimtm_sec=47, loctim.tm_wday=6, loctim.tm_yday=214, loctim.tm_isdst=0        if loctim.tm_yday != lasttime.tm_yday:            self.userTimes.buyCopperTimes = 0            userdat.buyCopperTimes = 0        else:            userdat.buyCopperTimes = self.userTimes.buyCopperTimes        lasttime2 = time.localtime(self.userTimes.lastBuyForageTime)        if loctim.tm_yday != lasttime2.tm_yday:            self.userTimes.buyForageTimes = 0            userdat.buyForageTimes = 0        else:            userdat.buyForageTimes = self.userTimes.buyForageTimes        lasttime3 = time.localtime(self.userTimes.lastBuyPKTime)        if loctim.tm_yday != lasttime3.tm_yday:            self.userTimes.buyPKtimes = 0            userdat.buyArenaTimes = 0        else:            userdat.buyArenaTimes = self.userTimes.buyPKtimes        lasttime4 = time.localtime(self.userTimes.lastBuyTowerTime)        if loctim.tm_yday != lasttime4.tm_yday:            self.userTimes.buyShiLianTimes = 0            userdat.buyTowerTimes = 0        else:            userdat.buyTowerTimes = self.userTimes.buyShiLianTimes        print 'back10002:\n'        print userdat        return userdat.SerializePartialToString()    def sreachUserDataFromMysql(self,datas,askid,callback = None):        if askid == askMysqlType.SQL_SelectLoginAccount:            #SELECT * FROM game.nettab_account where account = 'usertest129';            cmdstr = "SELECT * FROM `game`.`nettab_account` where `account` = '%s';\n"%(self.account)#获取玩家用户信息            cmdstr += "SELECT * FROM game.nettab_userherotab where `account` = '%s';\n"%(self.account)#获取玩家英雄信息            cmdstr += "SELECT * FROM game.nettab_useritemtab where `account` = '%s';\n"%(self.account)#获取玩家道具信息            cmdstr += "SELECT * FROM game.nettab_userskilltab where `account` = '%s';\n"%(self.account)#获取玩家英雄技能信息            cmdstr += "SELECT * FROM game.nettab_soliderskill where `account` = '%s';\n"%(self.account)#获取玩家教场信息            cmdstr += "SELECT * FROM game.nettab_outheros where `account` = '%s';\n"%(self.account)#获取玩家守城武将信息            cmdstr += "SELECT * FROM game.nettab_stageHeros where `account` = '%s';\n"%(self.account)#获取玩家出战武将信息            cmdstr += "SELECT * FROM `game`.`nettab_itembuytimes` where `account` = '%s';\n"%(self.account)#获取玩家已购买道具次数信息            cmdstr += "SELECT * FROM `game`.`nettab_task` where `account` = '%s';\n"%(self.account)#获取玩家已完成任务信息            def selectUserAccountFunc(mysqlobjtmp,askdatas = datas,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 6:                    self.initAccountFromMysql(mysqlobjtmp.data)                else:                    print '错误:get account data erro'                self.userCacheT.UserComplete(self.account,'login')#用户数据建立完成，请求建立连接线程转发用户游戏请求                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectUserAccountFunc)            else:                self.mysqlAsks[askid] = [selectUserAccountFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,4)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_SelectMapPoint:            #SELECT * FROM game.nettab_mapPoint where id = '100002';            cmdstr = "SELECT * FROM game.nettab_mapPoint where id = '%s';\n"%(datas)            def selectMapPoint(mysqlobjtmp,askdatas = datas,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if self.mappoints.has_key(datatmp[0]):                        self.mappoints[datatmp[0]] = [0]*30                        for ix in range(len(self.mappoints[datatmp[0]])):                            self.mappoints[datatmp[0]][ix] = datatmp[ix+3]                else:                    print "没有找到关卡塔点保存数据"                if cback != None:                    cback()        elif askid == askMysqlType.SQL_selectEmail:            #SELECT * FROM game.nettab_mapPoint where id = '100002';            cmdstr = "SELECT * FROM game.nettab_mapPoint where id = '%s';\n"%(datas)            def selectMapPoint(mysqlobjtmp,askdatas = datas,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if self.mappoints.has_key(datatmp[0]):                        self.mappoints[datatmp[0]] = [0]*30                        for ix in range(len(self.mappoints[datatmp[0]])):                            self.mappoints[datatmp[0]][ix] = datatmp[ix+3]                else:                    print "没有找到关卡塔点保存数据"                if cback != None:                    cback()        elif askid == askMysqlType.SQL_SelectUserName:            md5name = self.userCacheT.getMd5(datas)            cmdstr = "SELECT * FROM game.nettab_md5account where id = '%s';\n"%(md5name)            def selectMapPoint(mysqlobjtmp,askdatas = datas,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "没有找到用户名对应的帐号"                    if cback != None:                        cback(None)                    def initAccountFromMysql(self,datas):        for d in range(len(datas)):            if d == 0:#用户基础数据                #29个数据                #((u'usertest154', 50000L, 50000L, 0L, 0L, 60L, 0L, 0L, 50000L, 1L, 0L, 0L, 0L, None, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1449509954L, 0L, 0L, 0L, 0L, 0L),)                #`account`, `acer`, `copper`, `book`, `soul`, `forage`, `feats`, `medal`, `friendpoint`, `level`, `exp`, `vipLevel`, `vipScore`, `name`, `buyWarehouseSpace`, `buyHeroSpace`, `buyJunling`, `energyItemUseTimes`, `newHandStep`, `loginRewardStats`, `leveupRewardStats`, `lastGetEmailTime`, `bugTimes`, `addEnergyTime`, `tongID`, `tongnumber`,`lastLoginTime`                dattmp = datas[0][0]                self.resouce.acer = dattmp[1]                self.resouce.copper = dattmp[2]                self.resouce.book = dattmp[3]                self.resouce.soul = dattmp[4]                self.resouce.forage = dattmp[5]                self.resouce.feats = dattmp[6]                self.resouce.medal = dattmp[7]                self.resouce.friendpoint = dattmp[8]                self.userBase.level = dattmp[9]                self.userBase.exp = dattmp[10]                self.userBase.vipLevel = dattmp[11]                self.userBase.vipScore = dattmp[12]                if dattmp[13] == None:                    self.userBase.name = ''                else:                    self.userBase.name = dattmp[13]                self.userBase.buyWarehouseSpace = dattmp[14]                self.userBase.buyHeroSpace = dattmp[15]                self.userBase.buyJunling = dattmp[16]                self.userBase.energyItemUseTimes = dattmp[17]                self.userOtherData.newHandStep = dattmp[18]                self.userOtherData.loginRewardStats = dattmp[19]                self.userOtherData.leveupRewardStats = dattmp[20]                self.userOtherData.lastGetEmailTime = dattmp[21]                self.userOtherData.bugTimes = dattmp[22]                self.userOtherData.addEnergyTime = dattmp[23]                self.tongID = dattmp[24]                self.tongmemberID = dattmp[25]                self.stageHurdle1 = dattmp[26]                self.stageHurdle2 = dattmp[27]                self.stageHurdle3 = dattmp[28]                self.lastLoginTime = dattmp[29]                self.relogintimes = dattmp[30]                self.rechargeValue = dattmp[31]                self.isNewEmail = dattmp[32]                self.userTimes.buyForageTimes = dattmp[33]                self.userTimes.buyPKtimes = dattmp[34]                self.userTimes.canPKTimes = dattmp[35]                self.userTimes.buyShiLianTimes = dattmp[36]                self.userTimes.canShiLianTimes = dattmp[37]                self.userTimes.buyCopperTimes = dattmp[38]                self.userTimes.lastBuyCopperTime = dattmp[39]                self.userTimes.lastBuyForageTime = dattmp[40]                self.userTimes.lastBuyPKTime = dattmp[41]                self.userTimes.lastBuyTowerTime = dattmp[42]                self.userOtherData.towerHightst = dattmp[43]                self.userOtherData.vipRewardState = bool(dattmp[44])            elif d == 1:#英雄列表                #((1000153L, 42284L, u'usertest154', 1L, 0L, 0L), (1000154L, 42006L, u'usertest154', 1L, 0L, 0L))                self._initBaseHerosFromMysqlData(datas[d])            elif d == 2:#道具列表                self._initBaseItemWithMysqlDAta(datas[d])            elif d == 3:#英雄技能列表                self._InitBaseHeroSkillsWithMysqlData(datas[d])                #((10015L, u'usertest154', 284L, 1L, 0L, 0L, 0L, 42284L, 0L), (10016L, u'usertest154', 6L, 1L, 0L, 0L, 0L, 42006L, 0L))            elif d == 4:#教场列表                #((u'usertest154', 43101L, 43201L, 43301L, 43401L, 43501L, 43601L),)                self.batmanInfo.setBatmanDatWithMysqlData(datas[d][0])            elif d == 5:#守城英雄                #((u'usertest154', 0L, 0L, 0L),)                dattmp = datas[d][0]                self.userOutHeros = [dattmp[1],dattmp[2],dattmp[3]]            elif d == 6:#出战英雄                #((u'usertest154', 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L),)                dattmp = datas[d][0]                self.userStageHeros = [dattmp[1],dattmp[2],dattmp[3],dattmp[4],dattmp[5],dattmp[6],dattmp[7],dattmp[8],dattmp[9]]            elif d == 7:#玩家购买道具次数信息                #(u'test123476', None)                dattmp = datas[7][0]                if dattmp[1] == None or dattmp[1] == '':                    self.BuyedItems = {}                else:                    datitems = dattmp[1].split(';')                    for datx in datitems:                        itmps = datx.split(':')                        self.BuyedItems[int(itmps[0])] = int(itmps[1])            elif d == 8:#获取玩家已完成任务信息                dattmp = datas[8][0]                print dattmp                self.task.setComTaskFromMysql(dattmp[1], dattmp[2], dattmp[3])    def updateUserDataToMysql(self,datas,askid,callback = None):        if askid == askMysqlType.SQL_UpdataAccountTab:#datas为玩家帐号数据类型,1.资源(玩家资源数据),2.baseUser(玩家基础数据),3.stageHurdle(关卡进度),4.otherData(用户其他数据)            #UPDATE `game`.`nettab_account` SET `acer`='111', `copper`='222', `book`='333' WHERE `account`='usertest147';            cmdstr = "UPDATE `game`.`nettab_account` SET "            if datas == 'res':                cmdstr += "`acer`='%d',"%(int(self.resouce.acer)) + "`copper`='%d',"%(int(self.resouce.copper)) + "`book`='%d',"%(self.resouce.book) + "`soul`='%d',"%(int(self.resouce.soul)) + "`forage`='%d',"%(int(self.resouce.forage)) + "`feats`='%d',"%(int(self.resouce.feats)) + "`medal`='%d',"%(int(self.resouce.medal)) + "`friendpoint`='%d' "%(int(self.resouce.friendpoint))                cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'baseuser':                cmdstr += "`level`='%d',"%(int(self.userBase.level)) + "`exp`='%d',"%(int(self.userBase.exp)) + "`vipLevel`='%d',"%(int(self.userBase.vipLevel)) + "`vipScore`='%d',"%(int(self.userBase.vipScore)) + "`name`='%s',"%(int(self.userBase.name)) + "`buyWarehouseSpace`='%s',"%(int(self.userBase.buyWarehouseSpace)) + "`buyHeroSpace`='%s',"%(int(self.userBase.buyHeroSpace)) + "`buyJunling`='%s',"%(int(self.userBase.buyJunling)) + "`energyItemUseTimes`='%s' "%(int(self.userBase.energyItemUseTimes))                cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'stage':                cmdstr += "`stageHurdle1`='%d',"%(int(self.stageHurdle1)) + "`stageHurdle2`='%d',"%(int(self.stageHurdle2)) + "`stageHurdle3`='%d' "%(int(self.stageHurdle3))                cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'otherdata':                cmdstr += "`newHandStep`='%d',"%(int(self.userOtherData.newHandStep)) + "`loginRewardStats`='%d',"%(int(self.userOtherData.loginRewardStats)) + "`leveupRewardStats`='%d',"%(int(self.userOtherData.leveupRewardStats)) + "`lastGetEmailTime`='%d',"%(int(self.userOtherData.lastGetEmailTime)) + "`bugTimes`='%d',"%(int(self.userOtherData.bugTimes)) + "`addEnergyTime`='%d',"%(int(self.userOtherData.addEnergyTime)) + "`lastLoginTime`='%d',"%(int(self.lastLoginTime)) + "`relogintimes`='%d',"%(int(self.relogintimes)) + "`rechargeValue`='%d' "%(int(self.rechargeValue))                  cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'buycopper':#购买铜钱                cmdstr += "`acer`='%d',"%(int(self.resouce.acer)) + "`copper`='%d',"%(int(self.resouce.copper)) + "`buyCopperTimes`='%d',"%(int(self.userTimes.buyCopperTimes)) + "`lastBuyCopperTime`='%d' "%(int(self.userTimes.lastBuyCopperTime))                 cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'buyforage':#购买粮草                cmdstr += "`acer`='%d',"%(int(self.resouce.acer)) + "`forage`='%d',"%(int(self.resouce.forage)) + "`buyForageTimes`='%d',"%(int(self.userTimes.buyForageTimes)) + "`lastBuyForageTime`='%d' "%(int(self.userTimes.lastBuyForageTime))                 cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'buyPK':#购买竟技场                cmdstr += "`acer`='%d',"%(int(self.resouce.acer)) + "`canPKTimes`='%d',"%(int(self.userTimes.canPKTimes)) + "`buyPKtimes`='%d',"%(int(self.userTimes.buyPKtimes)) + "`lastBuyPKTime`='%d' "%(int(self.userTimes.lastBuyPKTimest))                 cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif datas == 'buyShiLian':#购买试练塔                cmdstr += "`acer`='%d',"%(int(self.resouce.acer)) + "`canShiLianTimes`='%d',"%(int(self.userTimes.canShiLianTimes)) + "`buyShiLianTimes`='%d',"%(int(self.userTimes.buyShiLianTimes)) + "`lastBuyTowerTime`='%d' "%(int(self.userTimes.lastBuyTowerTime))                 cmdstr += "WHERE `account`='%s';\n"%(str(self.account))            elif type(datas) == dict:                acc,ptype = datas.popitem()                cmdstr += "`isNewEmail`='%d' "%(ptype)                cmdstr += "WHERE `account`='%s';\n"%(str(acc))            def updataeUserDataFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeUserDataFunc)            else:                self.mysqlAsks[askid] = [updataeUserDataFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataHeros:#datas为英雄netIDs            #UPDATE `game`.`nettab_userherotab` SET `level`='55', `starleve`='1', `isOutHero`='0' WHERE `id`='1000144';            cmdstr = "UPDATE `game`.`nettab_userherotab` SET `level`='%d', `starleve`='%d', `isOutHero`='%d' WHERE `id`='%d';\n"%(int(self.heros[datas].heroLevel),int(self.heros[datas].heroStar),int(self.heros[datas].isOutHero),int(datas))            def updataeHeroFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeHeroFunc)            else:                self.mysqlAsks[askid] = [updataeHeroFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataHeroSkill:#datas为技能netIDs            #UPDATE `game`.`nettab_userskilltab` SET `level`='2', `skillType`='1', `quality`='2', `getpath`='0', `skillHeroNetID`='10007' WHERE `id`='10006';            cmdstr = "UPDATE `game`.`nettab_userskilltab` SET `level`='%d', `skillType`='%d', `skillHeroNetID`='%d' WHERE `id`='%d';\n"%(int(self.heroSkills[datas].skillLevel),int(self.heros[datas].skillType),int(self.heros[datas].skillHeroNetID),int(datas))            def updataeHeroSkillFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeHeroSkillFunc)            else:                self.mysqlAsks[askid] = [updataeHeroSkillFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataItems:#datas为道具netIDs            #UPDATE `game`.`nettab_useritemtab` SET `level`='2', `quality`='2', `star`='2', `count`='2', `itemUsedID`='10007', `itemuseTime`='1' WHERE `netid`='200003';            cmdstr = "UPDATE `game`.`nettab_useritemtab` SET `level`='%d', `quality`='%d', `star`='%d', `count`='%d', `itemUsedID`='%d', `itemuseTime`='%d' WHERE `netid`='%d';\n"%(int(self.items[datas].itemLevel),int(self.items[datas].itemQuality),int(self.items[datas].itemStar),int(self.items[datas].itemNumber),int(self.items[datas].itemUsedID),int(self.items[datas].itemuseTime),int(datas))            def updataeItemFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeItemFunc)            else:                self.mysqlAsks[askid] = [updataeItemFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataBuyItemTimes:#更新道具购买次数数据            strtmp = ""            cmdstr = ""            print "---------------------:%d"%(len(self.BuyedItems))            for k in self.BuyedItems.keys():                strtmp += str(k) + ":" + str(self.BuyedItems[k]) + ";"            if len(strtmp) > 1:                strtmp = strtmp[:-1]    #删除最后一个分号                cmdstr = "UPDATE `game`.`nettab_itembuytimes` SET `buymsg`='%s' WHERE `account`='%s';\n"%(strtmp,str(self.account))            else:                return            def updataebuyItemTimesFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataebuyItemTimesFunc)            else:                self.mysqlAsks[askid] = [updataebuyItemTimesFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataBatman:#教场保存数据编号,datas为编号,从1开始，最大为6            #UPDATE `game`.`nettab_soliderskill` SET `leveltype1`='3', `leveltype2`='3', `leveltype3`='3', `leveltype4`='3', `leveltype5`='3', `leveltype6`='3' WHERE `account`='usertest';            cmdstr = "UPDATE `game`.`nettab_soliderskill` SET `leveltype%d`='%d' WHERE `account`='%s';\n"%(int(datas),int(self.batmanInfo.getBatmanDatWithNumber(datas)),str(self.account))            def updataeBatmanFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeBatmanFunc)            else:                self.mysqlAsks[askid] = [updataeBatmanFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataCityHeros:#保存守城武将,直接读取武将数组,datas不相关            #UPDATE `game`.`nettab_outheros` SET `hero1`='1', `hero2`='1', `hero3`='1' WHERE `account`='usertest';            cmdstr = "UPDATE `game`.`nettab_outheros` SET `hero1`='%d', `hero2`='%d', `hero3`='%d' WHERE `account`='%s';\n"%(int(self.userOutHeros[0]),int(self.userOutHeros[1]),int(self.userOutHeros[2]),str(self.account))            def updataeCityHerosFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeCityHerosFunc)            else:                self.mysqlAsks[askid] = [updataeCityHerosFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataWarHeros:#保存武将出战武将,直接从user中取值datas无关,            #UPDATE `game`.`nettab_stageHeros` SET `hero1`='1', `hero2`='1', `hero3`='1', `hero4`='1', `hero5`='1', `hero6`='1', `hero7`='1', `hero8`='1', `hero9`='1' WHERE `account`='usertest';            cmdstr = "UPDATE `game`.`nettab_stageHeros` SET `hero1`='%d', `hero2`='%d', `hero3`='%d', `hero4`='%d', `hero5`='%d', `hero6`='%d', `hero7`='%d', `hero8`='%d', `hero9`='%d' WHERE `account`='%s';\n"%(int(self.userStageHeros[0]),int(self.userStageHeros[1]),int(self.userStageHeros[2]),int(self.userStageHeros[3]),int(self.userStageHeros[4]),int(self.userStageHeros[5]),int(self.userStageHeros[6]),int(self.userStageHeros[7]),int(self.userStageHeros[8]),str(self.account))            def updataeWarHerosFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeWarHerosFunc)            else:                self.mysqlAsks[askid] = [updataeWarHerosFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdateMapPoint:#地图网络id,datas为保存的网络ID，客户端接收的数据已经保存在user中.            #UPDATE `game`.`nettab_mapPoint` SET `pointstr`='2222' WHERE `id`='100003';            cmdstr = "UPDATE `game`.`nettab_mapPoint` SET `p%d`='%s' WHERE `id`='%s';\n"%(int(datas[1]),int(self.mappoints[datas[0]][datas[1]]),str(datas[0]))            def updataeMapPointFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeMapPointFunc)            else:                self.mysqlAsks[askid] = [updataeMapPointFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_UpdataUserTask:            #UPDATE `game`.`nettab_task` SET `taskDay`='10001,1', `taskStory`='20001,1', `dayNum`='1' WHERE `account`='user1';            cmdstr = "UPDATE `game`.`nettab_task` SET `taskDay`='%s', `taskStory`='%s', `dayNum`='%d' WHERE `account`='%s';\n"%(self.task.getMysqlDayStr(),self.task.getMySqlStoryStr(),self.task.getTimeDay(),str(self.account))            def updataeMapPointFunc(mysqlbackobj,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(updataeMapPointFunc)            else:                self.mysqlAsks[askid] = [updataeMapPointFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,3)#account,askid,datas,mysqltype):    def insetUserDataToMysql(self,datas,askid,callback = None):        if askid == askMysqlType.SQL_InsetRegisterAccount:#不关心datas,保存所有用户数据            #插入用户基础数据            #INSERT INTO `game`.`nettab_account` (`account`, `acer`, `copper`, `book`, `soul`, `forage`, `feats`, `medal`, `friendpoint`, `level`, `vipLevel`, `vipScore`, `name`, `buyWarehouseSpace`, `buyHeroSpace`, `buyJunling`, `energyItemUseTimes`, `newHandStep`, `loginRewardStats`, `leveupRewardStats`, `lastGetEmailTime`, `bugTimes`, `herocount`, `itemTypeCount`, `exp`, `tongID`, `tongnumber`) VALUES ('user', '0', '50000', '0', '0', '60', '0', '0', '0', '1', '0', '0', 'ww', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0');            cmdstr = "INSERT INTO `game`.`nettab_account` (`account`, `acer`, `copper`, `book`, `soul`, `forage`, `feats`, `medal`, `friendpoint`, `level`, `exp`, `vipLevel`, `vipScore`, `name`, `buyWarehouseSpace`, `buyHeroSpace`, `buyJunling`, `energyItemUseTimes`, `newHandStep`, `loginRewardStats`, `leveupRewardStats`, `lastGetEmailTime`, `bugTimes`, `addEnergyTime`, `tongID`, `tongnumber`) VALUES ("            cmdstr += "'" + str(self.account) +"','"+ str(self.resouce.acer) + "','" + str(self.resouce.copper) + "','" + str(self.resouce.book) + "','" + str(self.resouce.soul) + "','" + str(self.resouce.forage) + "','" + str(self.resouce.feats) + "','" + str(self.resouce.medal) + "','" + str(self.resouce.friendpoint) + "','" + str(self.userBase.level) + "','" + str(self.userBase.exp) + "','" + str(self.userBase.vipLevel) + "','" + str(self.userBase.vipScore) + "',NULL,'" + str(self.userBase.buyWarehouseSpace) + "','" + str(self.userBase.buyHeroSpace) + "','" + str(self.userBase.buyJunling) + "','" + str(self.userBase.energyItemUseTimes) + "','" + str(self.userOtherData.newHandStep) + "','" + str(self.userOtherData.loginRewardStats) + "','" + str(self.userOtherData.leveupRewardStats) + "','" + str(self.userOtherData.lastGetEmailTime) + "','" + str(self.userOtherData.bugTimes) + "','" + str(self.userOtherData.addEnergyTime) + "','" + str(self.tongID) + "','" + str(self.tongmemberID) + "');\n"            #这里要保存所有的mysql请求，方便mysql返回时处理返回数据            def registerInsetbackFunc(backmysqldata,askdatas = datas,paskid = askid,cBack = callback):                if callback != None:                    callback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(registerInsetbackFunc)            else:                self.mysqlAsks[askid] = [registerInsetbackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetHeros:#datas英雄配置id            if len(datas) == 0:                return            #INSERT INTO `game`.`nettab_userherotab` (`configid`, `account`, `level`, `starleve`, `isOutHero`) VALUES ('10001', 'woodcol', '1', '1', '1');            cmdstr1 = ''            for h in datas:                cmdstr1 += "INSERT INTO `game`.`nettab_userherotab` (`configid`, `account`, `level`, `starleve`, `isOutHero`) VALUES ("                herotmp = self.heros[self.heroConfigs[h]]                cmdstr1 += "'" + str(int(herotmp.heroCID)) + "','" + str(self.account) + "','" + str(int(herotmp.heroLevel)) + "','" + str(int(herotmp.heroStar)) + "','" + str(int(herotmp.isOutHero)) + "');\n"            cmdstr2 = "SELECT LAST_INSERT_ID();\n"            def insetHerosbackFunc(mysqlobject,askdatas = datas,paskid = askid,cBack = callback):                backdatas = mysqlobject.data                lastid = backdatas[0][0] - len(askdatas) + 1                for c in range(len(askdatas)):                    herotx = self.heros.pop(self.heroConfigs[askdatas[c]])                    herotx.heroNetID = lastid + c                    self.heros[herotx.heroNetID] = herotx                    self.heroConfigs[askdatas[c]] = herotx.heroNetID                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetHerosbackFunc)            else:                self.mysqlAsks[askid] = [insetHerosbackFunc]            self.userCacheT.askMysqlFromUserForInsetAutoID(self.account,askid,cmdstr1,cmdstr2)        elif askid == askMysqlType.SQL_InsetItems:#datas:道具配置id            if len(datas) == 0:                return            #INSERT INTO `game`.`nettab_useritemtab` (`toolconfigID`, `account`, `level`, `quality`, `star`, `count`, `itemUsedID`, `itemuseTime`) VALUES ('1006', '0', '1', '1', '1', '1', '10006', '0');            cmdstr1 = ''            for h in datas:                cmdstr1 += "INSERT INTO `game`.`nettab_useritemtab` (`toolconfigID`, `account`, `level`, `quality`, `star`, `count`, `itemUsedID`, `itemuseTime`, `type`) VALUES ("                itemtmp = self.items[h]                cmdstr1 += "'" + str(int(itemtmp.itemCID)) + "','" + str(self.account) + "','" + str(int(itemtmp.itemLevel)) + "','" + str(int(itemtmp.itemQuality)) + "','" + str(int(itemtmp.itemStar)) + "','" + str(int(itemtmp.itemNumber)) + "','" + str(int(itemtmp.itemUsedID)) + "','0','" + str(int(itemtmp.itemType)) +"');\n"            cmdstr2 = "SELECT LAST_INSERT_ID();\n"            def insetItemsbackFunc(mysqlobject,askdatas = datas,paskid = askid,cBack = callback):                backdatas = mysqlobject.data                lastid = backdatas[0][0] - len(askdatas) + 1                newids = []                for c in range(len(askdatas)):                    itemx = self.items.pop(askdatas[c])                    _cid = self.itemsNumbers.pop(askdatas[c])                    itemx.itemNetID = lastid +c                    self.items[itemx.itemNetID]= itemx                    newids.append(itemx.itemNetID)                if cBack != None:                    cBack(newids)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetItemsbackFunc)            else:                self.mysqlAsks[askid] = [insetItemsbackFunc]            self.userCacheT.askMysqlFromUserForInsetAutoID(self.account,askid,cmdstr1,cmdstr2)        elif askid == askMysqlType.SQL_InsetHeroSkill:#datas:技能配置id            if len(datas) == 0:                return            #INSERT INTO `game`.`nettab_userskilltab` (`account`, `configid`, `level`, `skillType`, `quality`, `getpath`, `skillHeroNetID`, `uptime`) VALUES ('0', '10006', '1', '0', '1', '1', '10006', '0');            cmdstr1 = ''            for h in datas:                cmdstr1 += "INSERT INTO `game`.`nettab_userskilltab` (`account`, `configid`, `level`, `skillType`, `quality`, `getpath`, `skillHeroNetID`, `uptime`) VALUES ("                heroskilltmp = self.heroSkills[h]                cmdstr1 += "'" + str(self.account) + "','" + str(int(heroskilltmp.skillCID)) + "','" + str(int(heroskilltmp.skillLevel)) + "','" + str(int(heroskilltmp.skillType)) + "','0','0','" + str(int(heroskilltmp.skillHeroNetID)) + "','0');\n"            cmdstr2 = "SELECT LAST_INSERT_ID();\n"            def insetHeroSkillBackFunc(mysqlobject,askdatas = datas,paskid = askid,cBack = callback):                backdatas = mysqlobject.data                lastid = backdatas[0][0] - len(askdatas) + 1                print askdatas                for c in range(len(askdatas)):                    hseroSkillx = self.heroSkills.pop(askdatas[c])                              #取出使用配置ID保存的英雄技能                    hseroSkillx.skillNetID = lastid +c                                          #设置技能的网络ID                    hseroSkillx.skillCID = self.heroSkillConfigs.pop(askdatas[c])                    print hseroSkillx.skillNetID,self.heroConfigs[hseroSkillx.skillHeroNetID],hseroSkillx.skillCID                    self.heros[self.heroConfigs[hseroSkillx.skillHeroNetID]].skillNetID = hseroSkillx.skillNetID  #在武将中保存技能网络ID                    hseroSkillx.skillHeroNetID = self.heroConfigs[hseroSkillx.skillHeroNetID]                    self.heroSkills[hseroSkillx.skillNetID]= hseroSkillx                        #重新用技能网络ID保存技能数据                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetHeroSkillBackFunc)            else:                self.mysqlAsks[askid] = [insetHeroSkillBackFunc]            self.userCacheT.askMysqlFromUserForInsetAutoID(self.account,askid,cmdstr1,cmdstr2)        elif askid == askMysqlType.SQL_InsetBuyItemTimes:#插入道具购买次数数据            strtmp = ""            cmdstr = ""            for k in self.BuyedItems.keys():                strtmp += str(k) + ":" + str(self.BuyedItems[k]) + ";"            if len(strtmp) > 1:                strtmp = strtmp[:-1]    #删除最后一个分号                cmdstr = "INSERT INTO `game`.`nettab_itembuytimes` (`account`, `buymsg`) VALUES ('%s', '%s');\n"%(str(self.account),strtmp)            else:                cmdstr = "INSERT INTO `game`.`nettab_itembuytimes` (`account`, `buymsg`) VALUES ('%s', NULL);\n"%(str(self.account))            def insetBuyTimesBackFunc(mysqlobject,paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetBuyTimesBackFunc)            else:                self.mysqlAsks[askid] = [insetBuyTimesBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetMapPoint:#datas:地图id            #datas:{mapid:mapid,points:{1:heroid,2:soliertype,...}}            #INSERT INTO `game`.`nettab_mapPoint` (`account`, `mapid`,`pointstr`) VALUES ('user2', '103','null');            dataid = datas            cmdstr = "INSERT INTO `game`.`nettab_mapPoint` (`id`,`account`, `mapid`,`p%d`) VALUES ('%s','%s','%d','%d');\n"%(int(datas[1]),str(datas[0]),str(self.account),int(datas[2]),int(self.mappoints[datas[0]][datas[1]]))            def insetMapPointsBackFunc(mysqlobject,askdataid = dataid,paskid = askid,cBack = callback):                backdatas = mysqlobject.data                print backdatas                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetMapPointsBackFunc)            else:                self.mysqlAsks[askid] = [insetMapPointsBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)        elif askid == askMysqlType.SQL_InsetBatman:#datas不关心,保存当前用户教场信息            #INSERT INTO `game`.`nettab_soliderskill` (`account`, `leveltype1`, `leveltype2`, `leveltype3`, `leveltype4`, `leveltype5`, `leveltype6`) VALUES ('usertest', '1', '1', '1', '1', '1', '1');            cmdstr = "INSERT INTO `game`.`nettab_soliderskill` (`account`, `leveltype1`, `leveltype2`, `leveltype3`, `leveltype4`, `leveltype5`, `leveltype6`) VALUES ("            cmdstr += "'" + str(self.account) + "','" + str(int(self.batmanInfo.dao)) + "','" + str(int(self.batmanInfo.qiang)) + "','" + str(int(self.batmanInfo.chui)) + "','" + str(int(self.batmanInfo.gong)) + "','" + str(int(self.batmanInfo.ceshi)) + "','" + str(int(self.batmanInfo.nvbing)) + "');\n"            #这里要保存所有的mysql请求，方便mysql返回时处理返回数据            def InsetSoliderSkillBackFunc(backmysqldata,askdatas = [],paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(InsetSoliderSkillBackFunc)            else:                self.mysqlAsks[askid] = [InsetSoliderSkillBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetWarHeros:#datas:不关心,保存当前用户战斗英雄            #INSERT INTO `game`.`nettab_stageHeros` (`account`, `hero1`, `hero2`, `hero3`, `hero4`, `hero5`, `hero6`, `hero7`, `hero8`, `hero9`) VALUES ('usertest', '0', '0', '0', '0', '0', '0', '0', '0', '0');            cmdstr = "INSERT INTO `game`.`nettab_stageHeros` (`account`, `hero1`, `hero2`, `hero3`, `hero4`, `hero5`, `hero6`, `hero7`, `hero8`, `hero9`) VALUES ("            cmdstr += "'" + str(self.account) + "','" + str(self.userStageHeros[0]) + "','" + str(self.userStageHeros[1]) + "','" + str(self.userStageHeros[2]) + "','" + str(self.userStageHeros[3]) + "','" + str(self.userStageHeros[4]) + "','" + str(self.userStageHeros[5]) + "','" + str(self.userStageHeros[6]) + "','" + str(self.userStageHeros[7]) + "','" + str(self.userStageHeros[8]) + "');\n"            #这里要保存所有的mysql请求，方便mysql返回时处理返回数据            def InsetStageHerosBackFunc(backmysqldata,askdatas = [],paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(InsetStageHerosBackFunc)            else:                self.mysqlAsks[askid] = [InsetStageHerosBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetCityHeros:#datas:不关心,保存当前用户守城武将            #INSERT INTO `game`.`nettab_outheros` (`account`, `hero1`, `hero2`, `hero3`) VALUES ('usertest', '0', '0', '0');            cmdstr = "INSERT INTO `game`.`nettab_outheros` (`account`, `hero1`, `hero2`, `hero3`) VALUES ("            cmdstr += "'" + str(self.account) + "','" + str(self.userOutHeros[0]) + "','" + str(self.userOutHeros[1]) + "','" + str(self.userOutHeros[2]) + "');\n"            #这里要保存所有的mysql请求，方便mysql返回时处理返回数据            def InsetOutHerosBackFunc(backmysqldata,askdatas = [],paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(InsetOutHerosBackFunc)            else:                self.mysqlAsks[askid] = [InsetOutHerosBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetUserTask:#            #INSERT INTO `game`.`nettab_task` (`account`, `taskDay`, `taskStory`, `dayNum`) VALUES ('user1', '10001,0', '20001,0', '0');            cmdstr = "INSERT INTO `game`.`nettab_task` (`account`) VALUES ('%s');\n"%(self.account)            def InsettaskBackFunc(backmysqldata,askdatas = [],paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(InsettaskBackFunc)            else:                self.mysqlAsks[askid] = [InsettaskBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetUserNameMd5:#            if self.userBase.name == '' or self.userBase.name == None:                return            md5name = self.userCacheT.getMd5(str(self.userBase.name))            #INSERT INTO `game`.`nettab_md5account` (`md5id`, `account`) VALUES ('1111', 'qqqqqq');            cmdstr = "INSERT INTO `game`.`nettab_md5account` (`md5id`, `account`) VALUES ('%s', '%s');\n"%(str(md5name),self.account)            def InsetUserNameBackFunc(backmysqldata,askdatas = [],paskid = askid,cBack = callback):                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(InsetUserNameBackFunc)            else:                self.mysqlAsks[askid] = [InsetUserNameBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,1)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_InsetEmail:#插入新邮件，这里插入的帐号是其他玩家帐号            if len(datas) == 0:                return            emaildata = self.Email.sendEmailData[datas]            datadict = emaildata.getDictData()            #{'to':'toaccount','title','title','content','type',1,'times':'','heros':'','res':''}            #INSERT INTO `game`.`nettab_email` (`from`, `to`, `title`, `content`, `type`, `items`, `heros`, `res`) VALUES ('account', 'account', 'title', 'content', '3', '10002,200', '42001', '2,50');            cmdstr1 = "INSERT INTO `game`.`nettab_email` (`from`, `to`, `title`, `content`, `type`, `items`, `heros`, `res`) VALUES ("            cmdstr1 += "'" + str(self.account) + "'"            if datadict.has_key('to'):                cmdstr1 += ",'" + str(datadict['to']) + "'"            if datadict.has_key('title'):                cmdstr1 += ",'" + str(datadict['title']) + "'"            if datadict.has_key('content'):                cmdstr1 += ",'" + str(datadict['content']) + "'"            if datadict.has_key('type'):                cmdstr1 += ",'" + str(datadict['type']) + "'"            if datadict.has_key('items'):                cmdstr1 += ",'" + str(datadict['items']) + "'"            if datadict.has_key('heros'):                cmdstr1 += ",'" + str(datadict['heros']) + "'"            if datadict.has_key('res'):                cmdstr1 += ",'" + str(datadict['res']) + "'"            cmdstr1 +=  ");\n"            cmdstr2 = "SELECT LAST_INSERT_ID();\n"            def insetSendEmailBackFunc(mysqlobject,askdatas = datas,paskid = askid,cBack = callback):                backdatas = mysqlobject.data                emaildata = self.Email.sendEmailData.pop(askdatas)                self.Email.perSendEmailData.append(backdatas[0][0])                if cBack != None:                    cBack()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(insetSendEmailBackFunc)            else:                self.mysqlAsks[askid] = [insetSendEmailBackFunc]            self.userCacheT.askMysqlFromUserForInsetAutoID(self.account,askid,cmdstr1,cmdstr2)    def deleteUserDataFromMysql(self,datas,askid,callback = None):        if askid  == askMysqlType.SQL_DeleteAccountTab:#玩家删除用户,这个一般不会操作            pass        elif askid == askMysqlType.SQL_DeleteHeros:#玩家解雇武将，同时注意删除英雄技能,删除英雄,datas为英雄网络id            #DELETE FROM `game`.`nettab_userherotab` WHERE `id`='1000144';            cmdstr = "DELETE FROM `game`.`nettab_userherotab` WHERE `id`='%d';\n"%(datas)            def deleteHeroBackFunc(backmysqldata,askdatas = [],paskid = askid,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(deleteHeroBackFunc)            else:                self.mysqlAsks[askid] = [deleteHeroBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,2)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_DeleteHeroSkill:#玩家删除武将技能            #DELETE FROM `game`.`nettab_userskilltab` WHERE `id`='10006';            cmdstr = "DELETE FROM `game`.`nettab_userskilltab` WHERE `id`='%d';\n"%(datas)            def deleteHeroSkillBackFunc(backmysqldata,askdatas = [],paskid = askid,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(deleteHeroSkillBackFunc)            else:                self.mysqlAsks[askid] = [deleteHeroSkillBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,2)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_DeleteItems:#datas:网络ids,玩家分解道具或者使用了全部道具,删除道具            #DELETE FROM `game`.`nettab_useritemtab` WHERE `netid`='200003';            cmdstr = "DELETE FROM `game`.`nettab_useritemtab` WHERE `netid`='%d';\n"%(datas)            def deleteItemBackFunc(backmysqldata,askdatas = [],paskid = askid,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(deleteItemBackFunc)            else:                self.mysqlAsks[askid] = [deleteItemBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,2)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_DeleteEmail:#datas:玩家buff网络id,这个功能取消            #DELETE FROM `game`.`nettab_email` WHERE `id`='3';            cmdstr = "DELETE FROM `game`.`nettab_email` WHERE `id`='%d';\n"%(datas)            def deleteEmailBackFunc(backmysqldata,askdatas = [],paskid = askid,cback = callback):                if cback != None:                    cback()            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(deleteEmailBackFunc)            else:                self.mysqlAsks[askid] = [deleteEmailBackFunc]            self.userCacheT.askMysqlFromUser(self.account,askid,cmdstr,2)#account,askid,datas,mysqltype):        elif askid == askMysqlType.SQL_DeleteUserBuff:#datas:玩家buff网络id,这个功能取消            pass    def receiveMysqlData(self,askid,mysqlobj):        if self.mysqlAsks.has_key(askid):            backfunc = self.mysqlAsks[askid][0]            backfunc(mysqlobj)            self.mysqlAsks[askid][0] = None            if len(self.mysqlAsks[askid]) > 1:                self.mysqlAsks[askid] = self.mysqlAsks[askid][1:]            else:                self.mysqlAsks[askid] = []    def _initUserAccountWithClientObj(self,clientobj):        handlertmp = clientobj.handler        self.csocket = clientobj.csocket        if handlertmp.cmd == 10001:         #10001    玩家注册账号            registrequest = Cmds_pb2.RequestRegisterAccount()            registrequest.ParseFromString(clientobj.data)            self.pw = registrequest.password            self.phone = registrequest.phone            self.userType = registrequest.userType            self.machingNumber = registrequest.machingNumber            self.createUserWithBaseConfig()             #创建玩家初始英雄            self.insetUserDataToMysql('insetdata', askMysqlType.SQL_InsetRegisterAccount)       #保存用户数据            self.insetUserDataToMysql(self.heroConfigs.keys(), askMysqlType.SQL_InsetHeros)     #保存武将信息            self.insetUserDataToMysql(self.heroSkills.keys(), askMysqlType.SQL_InsetHeroSkill)  #保存所有武将技能            self.insetUserDataToMysql(self.itemsNumbers.keys(), askMysqlType.SQL_InsetItems)           #保存道具信息            self.insetUserDataToMysql('', askMysqlType.SQL_InsetBatman)                         #保存教场信息            self.insetUserDataToMysql('', askMysqlType.SQL_InsetCityHeros)                      #保存守城武将信息            self.insetUserDataToMysql('', askMysqlType.SQL_InsetWarHeros)                       #保存出战武将信息            self.insetUserDataToMysql('', askMysqlType.SQL_InsetBuyItemTimes)                   #保存购买道具次数信息            def createUserEnd():                self.userCacheT.UserComplete(self.account,'login')#用户数据建立完成，请求建立连接线程转发用户游戏请求            self.insetUserDataToMysql('', askMysqlType.SQL_InsetUserTask,createUserEnd)                        #mysql将新玩家数据保存到数据库中        elif handlertmp.cmd == 10002:       #10002    账号密码登陆            loginrequest = Cmds_pb2.RequestLoginByAccount()            loginrequest.ParseFromString(clientobj.data)            print loginrequest            self.userType = loginrequest.userType            self.account = loginrequest.userAccount            self.pw = loginrequest.password            self.createUserWithBaseConfig()            self.createUserDataFromMysql()  #实际上这里要调用这条方法从服务器获取玩家数据                    elif handlertmp.cmd == 10003:       #10003    使用设备码登录(直接登录)            pass        elif handlertmp.cmd == 10004:       #10004    修改密码            pass        elif handlertmp.cmd == 10005:       #10005    获取游戏服务器列表            pass        elif handlertmp.cmd == 10006:       #10006    访问游戏服务器接口            pass        elif handlertmp.cmd == 10007:       #10007    转发到登陆服务器登陆            pass        elif handlertmp.cmd == 10008:       #10008    获取客户端数据配置表md5效验码            pass        elif handlertmp.cmd == 10009:       #10009    服务器心跳包，返回当前服务器时间            pass    def splitCastGoodsWithOneStrToIntDats(self,nstr,splitstr = ';'):#使用一种字符分割字符串        tmplist = []        stmps = nstr.split(splitstr)        for xs in stmps:            tmplist.append(int(xs))        return tmplist    def splitCastGoodsWithTowStrToIntDats(self,nstr,splitstr1 = '|',splitstr2 = ';'):#使用两种字符分割字符串，从字符串中分出请求所需资源或道具信息        if nstr == 'null':            return None        backlist = []        nstrs = nstr.split(splitstr1)        for ntmp in nstrs:            stmps = ntmp.split(splitstr2)            tmplist = []            for xs in stmps:                tmplist.append(int(xs))            backlist.append(tmplist)        return backlist    #检测请求消耗所需物品够不够[[物品类型,物品ID,物品数量],...]。返回[[物品类型，物品ID,物品消耗后剩余数量],...]    #isCast,是否扣除所需消耗物品，是:检测同时扣除消耗品(如果可够扣除，否则返回扣除失败)，否:只显示消耗后剩余数量不作资源扣除    def testCastGoods(self,goods,isCast = True):#使用道具配置ID消耗道具,返回道具网络ID用于更新数据库        backlist = []        isCastEnough = True        for g in goods:            goodtype = g[0]            goodnum = g[2]            tmplist = []            tmplist.append(goodtype)            tmplist.append(g[1])            if goodtype == 1:#消耗为元宝资源,acer                if goodnum > self.resouce.acer:                    isCastEnough = False                tmplist.append(self.resouce.acer - goodnum)            elif goodtype == 2:#消耗为铜钱资源,copper                if goodnum > self.resouce.copper:                    isCastEnough = False                tmplist.append(self.resouce.copper - goodnum)            elif goodtype == 3:#消耗为古籍资源,book                if goodnum > self.resouce.book:                    isCastEnough = False                tmplist.append(self.resouce.book - goodnum)            elif goodtype == 4:#消耗为将魂资源,soul                if goodnum > self.resouce.soul:                    isCastEnough = False                tmplist.append(self.resouce.soul - goodnum)            elif goodtype == 5:#消耗为粮草资源,forage                if goodnum > self.resouce.forage:                    isCastEnough = False                tmplist.append(self.resouce.forage - goodnum)            elif goodtype == 6:#消耗为军功资源,feats                if goodnum > self.resouce.feats:                    isCastEnough = False                tmplist.append(self.resouce.feats - goodnum)            elif goodtype == 7:#勋章,medal                if goodnum > self.resouce.medal:                    isCastEnough = False                tmplist.append(self.resouce.medal - goodnum)            elif goodtype == 8:#友情点,friendpoint                if goodnum > self.resouce.friendpoint:                    isCastEnough = False                tmplist.append(self.resouce.friendpoint - goodnum)            elif goodtype == 9:#英雄,hero                hnidtmp = 0                for hk in self.heros.keys():                    if self.heros[hk].heroCID == g[1]:                        hnidtmp = hk                        break;                if hnidtmp != 0:                    tmplist[1] = hnidtmp                    tmplist.append(goodnum)                else:                    isCastEnough = False                    tmplist.append(-1)            elif goodtype == 10:#道具,item                itemnidtmp = 0                for ik in self.items.keys():                    if self.items[ik].itemCID == g[1]:                        itemnidtmp = ik                if itemnidtmp != 0 and self.items[itemnidtmp].itemNumber > goodnum:                    tmplist[1] = itemnidtmp                    tmplist.append(goodnum)                else:                    isCastEnough = False                    tmplist.append(-1)            elif goodtype == 11:#装备,equip                itemnidtmp = 0                for ik in self.items.keys():                    if self.items[ik].itemCID == g[1]:                        itemnidtmp = ik                if itemnidtmp != 0:                    tmplist[1] = itemnidtmp                    tmplist.append(goodnum)                else:                    isCastEnough = False                    tmplist.append(-1)            backlist.append(tmplist)        if isCast and isCastEnough:#作资源检测之后扣除消耗物品            for lx in backlist:                goodtype = lx[0]                goodnum = lx[2]                if goodtype == 1:#消耗为元宝资源,acer                    self.resouce.acer = goodnum                    lx[2] = self.resouce.acer                elif goodtype == 2:#消耗为铜钱资源,copper                    self.resouce.copper = goodnum                    lx[2] = self.resouce.copper                elif goodtype == 3:#消耗为古籍资源,book                    self.resouce.book = goodnum                    lx[2] = self.resouce.book                elif goodtype == 4:#消耗为将魂资源,soul                    self.resouce.soul = goodnum                    lx[2] = self.resouce.soul                elif goodtype == 5:#消耗为粮草资源,forage                    self.resouce.forage = goodnum                    lx[2] = self.resouce.forage                    tmplist.append(self.resouce.forage - goodnum)                elif goodtype == 6:#消耗为军功资源,feats                    self.resouce.feats = goodnum                    lx[2] = self.resouce.feats                elif goodtype == 7:#勋章,medal                    self.resouce.medal = goodnum                    lx[2] = self.resouce.medal                elif goodtype == 8:#友情点,friendpoint                    self.resouce.friendpoint = goodnum                    lx[2] = self.resouce.friendpoint                elif goodtype == 9:#英雄,hero,在装备，道具或武将合成中使用,消耗此武将                    hnidtmp = lx[1]#获取英雄网络ID,这里的消耗品为武将，这里将会把这个武将删除,                elif goodtype == 10:#道具,item                    itemnidtmp = lx[1]#所要使用道具的网络ID                    self.items[itemnidtmp].itemNumber -= goodnum                elif goodtype == 11:#装备,equip，在装备或道具合成中使用,消耗此装备                    itemnidtmp = lx[1]#消耗的装备网络ID,这里会将当前装备从数据中删除，        return isCastEnough,backlist    def getPercentResult(self,percent): #物品是否掉落        tmprandom = random.randrange(0,100)        if tmprandom < percent:            return True        else:            return False    #玩家增加资源或道具    def rewardUserGoods(self,goods,callback = None,vips = None):        backgoods = []        for gi in range(len(goods)):#一次为玩家增加多种道具或者资源            gooddats = goods[gi]            print gooddats            vipdats = vips  #vip等级,奖励倍数            cbacktmp = None            if gi == len(goods) -1:                cbacktmp = callback            if gooddats[0] <= 8:#奖励资源                rcount = gooddats[2]                if vipdats and self.userBase.vipLevel >= vipdats[0]:                    rcount = gooddats[2]*vipdats[1]                restmp = self.resouce.getResWithNameOrType(gooddats[0]) + rcount                                def loginbackFunc(insetnid = 0,confids = gooddats,cback = cbacktmp,backgoodstmp = backgoods):                    backtmp = []                    backtmp.append(confids[0])                    backtmp.append(confids[1])                    backtmp.append(confids[2])                    backgoodstmp.append(backtmp)                    if cback:                        cback(backgoodstmp)                self.resouce.setResWithNameOrType(gooddats[0], restmp)                self.updateUserDataToMysql('res', askMysqlType.SQL_UpdataAccountTab,loginbackFunc)            elif gooddats[0] == 9:#签到奖励英雄                goodcid = gooddats[1]                hcids,skills = self._insetNewHeroWithID([gooddats[1]])                def insetMysqlBackFunc2(gherocid = goodcid,gskillids = skills,goodtmps = gooddats,cback = cbacktmp,backgoodstmp = backgoods):                    backtmp = []                    backtmp.append(goodtmps[0])                    backtmp.append(self.heroConfigs[gherocid])                          #英雄网络ID                    backtmp.append(self.heros[self.heroConfigs[gherocid]].skillNetID)   #英雄技能网络ID                    backgoodstmp.append(backtmp)                    if cback:                        cback(backgoodstmp)                self.insetUserDataToMysql(hcids, askMysqlType.SQL_InsetHeros)                self.insetUserDataToMysql(skills, askMysqlType.SQL_InsetHeroSkill,insetMysqlBackFunc2)            elif gooddats[0] == 10:#签到送道具                goodcid = gooddats[1]                itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                rcount = gooddats[2]                if vipdats and self.userBase.vipLevel >= vipdats[0]:                    rcount = gooddats[2]*vipdats[1]                itemNetID = 0                for itx in self.items.keys():                    if self.items[itx].itemCID == goodcid:                        itemNetID = itx                if itemNetID != 0:                    if self.items[itemNetID].itemNumber >= int(itemtabdat['stackNums']):                        continue                    else:                         self.items[itemNetID].itemNumber += rcount   #增加道具数据                        if self.items[itemNetID].itemNumber > int(itemtabdat['stackNums']):                            self.items[itemNetID].itemNumber = int(itemtabdat['stackNums'])                        def loginItemMysqlBackFunc2(itemNID = itemNetID,goodtmps = gooddats,cback = cbacktmp,backgoodstmp = backgoods):                            backtmp = []                            backtmp.append(goodtmps[0])                            backtmp.append(itemNID)                          #英雄网络ID                            backtmp.append(goodtmps[2])   #英雄技能网络ID                            backgoodstmp.append(backtmp)                            if cback:                                cback(backgoodstmp)                        self.updateUserDataToMysql(itemNetID, askMysqlType.SQL_UpdataItems,loginItemMysqlBackFunc2)                else:                    itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                    self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = int(rcount),itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                    print itemuserid                    def loginItemMysqlFunc(itemNewNIDs,itemuid = itemuserid,goodtmps = gooddats,cback = cbacktmp,backgoodstmp = backgoods):                        if self.itemsNumbers.has_key(itemuid):                            _cid = self.itemsNumbers.pop(itemuid)                        backtmp = []                        backtmp.append(goodtmps[0])                        backtmp.append(itemNewNIDs[0])                          #英雄网络ID                        backtmp.append(goodtmps[2])   #英雄技能网络ID                        backgoodstmp.append(backtmp)                        if cback:                            cback(backgoodstmp)                    self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc)            elif gooddats[0] == 11:#签到送装备                goodcid = gooddats[1]                itemtabdat = self.userCacheT.getConfigDataWithTableNameAndID('tab_goods',goodcid)                itemuserid = self.getItemNewIndex(goodcid)#新道具的临时ID                self.items[itemuserid] = _Item(itemNetID = itemuserid,itemCID = goodcid,itemLevel = 1,quality = int(itemtabdat['rank']) ,itemStar = int(itemtabdat['equipStarInit']),itemuseTime = 0,itemNumber = 1,itemUsedID = -1,ptype = int(itemtabdat['equipCoordinate']))                #扣除消耗资源                def loginItemMysqlFunc3(itemNewNIDs,itemuid = itemuserid,goodtmps = gooddats,cback = cbacktmp,backgoodstmp = backgoods):                    if self.itemsNumbers.has_key(itemuid):                        _cid = self.itemsNumbers.pop(itemuid)                    backtmp = []                    backtmp.append(goodtmps[0])                    backtmp.append(itemNewNIDs[0])                          #英雄网络ID                    backtmp.append(goodtmps[2])   #英雄技能网络ID                    backgoodstmp.append(backtmp)                    if cback:                        cback(backgoodstmp)                self.insetUserDataToMysql([itemuserid], askMysqlType.SQL_InsetItems,loginItemMysqlFunc3)