#!/usr/bin/env python# -*- coding: utf-8 -*-#排行榜线程import threadingimport Queueimport QueueObjsimport askMysqlTypeimport randomfrom random import randrange, randintclass UserRankingT(threading.Thread):    def __init__(self,t_name,threadmangert):        threading.Thread.__init__(self, name=t_name)         self.threadmangert = threadmangert        self.queumanger = self.threadmangert.queumangert        self.ranking = []               #排行榜,[[用户名,总战力,帐号],[用户名,总战力,帐号],...]        self.rankaccounts = {}          #{帐号:排名}        self.queueRequest = Queue.Queue()        self.queuemangert.saveThreadMailQueueWithName(t_name, self.queueReauest)    #保存线程名        self.usercachTs = []            #请求排行榜的用户线程 [玩家帐号]        self.rankingMax = 0             #排行榜最大值        self.rankingMaxValue = 0        #排行榜最大值玩家战力        #mysql数据库相关        self.mysqlAsks = {}                         #数据库已发送请求列队{askid:[backFunc]}        #UserCache        self.mysqlUnUsedQueues = {}        #mysql        self.mysqlIndex = 100                               #mysql请求编号,从100号开始，100号以下的留给用户管理器器自已用,1:获取服务器列表        #获取mysql线程请求列队        mysqlqueue,mysqlThreadName = self.threadmangert.getCanUseMysqlThreadForOther(self.getName()) #mysql数据请求，需要时再请求，不用时马上释放连接,所以这里不作请求#mysql请求线程名                                     if mysqlqueue == None or mysqlThreadName == None:            print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserMangerT)'        self.mysqlUnUsedQueues[mysqlThreadName] = mysqlqueue        #已请求到的未使用的mysql连接        self.mysqlUsedQueues = {}                                   #正在使用的mysql连接        self.mysqlRequests = {}                                     #mysql请求编号            def getUserPKRankingWithAccount(self,account):                  #获取玩家排行榜        def getRankingBack(data):            print data        self.getUserRanking(account, getRankingBack)    def getUserAttackUserWithAccount(self,account):                 #通过玩家帐号获取玩家可打军机处数据        def callbackFunc(data):            print data        self.getAccountAttackUsers(account, callbackFunc)    def getAccountAttackUsers(self,account,callback):               #获取可挑战玩家数据        rankingid = self.rankaccounts[account]        if rankingid > 10000:            ids = random.sample(range(rankingid - 1000,rankingid), 3)            #SELECT * FROM game.nettab_ranking where id in (1,2,4);    #取三个玩家帐号数据            cmdstr = "SELECT * FROM game.nettab_ranking where id in (%d,%d,%d);\n"%(ids[0],ids[1],ids[2]) #查询某个玩家排行榜数据            askid = askMysqlType.SQL_SelectUserRanking            def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "未读取到最大排行榜数据"                    if cback != None:                        cback(None)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectMaxRanking)            else:                self.mysqlAsks[askid] = [selectMaxRanking]            self.askMysqlFromUser(askid,cmdstr,4)        elif rankingid > 1000:            ids = random.sample(range(rankingid - 100,rankingid), 3)            #SELECT * FROM game.nettab_ranking where id in (1,2,4);    #取三个玩家帐号数据            cmdstr = "SELECT * FROM game.nettab_ranking where id in (%d,%d,%d);\n"%(ids[0],ids[1],ids[2]) #查询某个玩家排行榜数据            askid = askMysqlType.SQL_SelectUserRanking            def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "未读取到最大排行榜数据"                    if cback != None:                        cback(None)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectMaxRanking)            else:                self.mysqlAsks[askid] = [selectMaxRanking]            self.askMysqlFromUser(askid,cmdstr,4)        elif rankingid > 100:            ids = random.sample(range(rankingid - 20,rankingid), 3)            #SELECT * FROM game.nettab_ranking where id in (1,2,4);    #取三个玩家帐号数据            cmdstr = "SELECT * FROM game.nettab_ranking where id in (%d,%d,%d);\n"%(ids[0],ids[1],ids[2]) #查询某个玩家排行榜数据            askid = askMysqlType.SQL_SelectUserRanking            def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "未读取到最大排行榜数据"                    if cback != None:                        cback(None)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectMaxRanking)            else:                self.mysqlAsks[askid] = [selectMaxRanking]            self.askMysqlFromUser(askid,cmdstr,4)        elif rankingid <= 3:            id1 = 1            id2 = 2            id3 = 3            #SELECT * FROM game.nettab_ranking where id in (1,2,4);    #取三个玩家帐号数据            cmdstr = "SELECT * FROM game.nettab_ranking where id in (%d,%d,%d);\n"%(id1,id2,id3) #查询某个玩家排行榜数据            askid = askMysqlType.SQL_SelectUserRanking            def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "未读取到最大排行榜数据"                    if cback != None:                        cback(None)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectMaxRanking)            else:                self.mysqlAsks[askid] = [selectMaxRanking]            self.askMysqlFromUser(askid,cmdstr,4)        else:            ids = random.sample(range(1,rankingid), 3)            #SELECT * FROM game.nettab_ranking where id in (1,2,4);    #取三个玩家帐号数据            cmdstr = "SELECT * FROM game.nettab_ranking where id in (%d,%d,%d);\n"%(ids[0],ids[1],ids[2]) #查询某个玩家排行榜数据            askid = askMysqlType.SQL_SelectUserRanking            def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):                if len(mysqlobjtmp.data) > 0:                    print mysqlobjtmp.data                    datatmp = mysqlobjtmp.data[0]                    if cback != None:                        cback(datatmp)                else:                    print "未读取到最大排行榜数据"                    if cback != None:                        cback(None)            if self.mysqlAsks.has_key(askid):                self.mysqlAsks[askid].append(selectMaxRanking)            else:                self.mysqlAsks[askid] = [selectMaxRanking]            self.askMysqlFromUser(askid,cmdstr,4)            def swapRankWithTwoUser(self,account1,account2):                #交换数据库中的两个玩家排行榜数据        rankID1 = self.rankaccounts[account1]        rankID2 = self.rankaccounts[account2]        rank1name = self.ranking[rankID1][0]        rank1value = self.ranking[rankID1][1]        rank1account = self.ranking[rankID1][2]        self.ranking[rankID1][0] = self.ranking[rankID2][0]        self.ranking[rankID1][1] = self.ranking[rankID2][1]        self.ranking[rankID1][2] = self.ranking[rankID2][2]        self.ranking[rankID2][0] = rank1name        self.ranking[rankID2][1] = rank1value        self.ranking[rankID2][2] = rank1account        self.updataUserRankingForTowUser(rankID1, self.ranking[rankID1], rankID2, self.ranking[rankID2], None)    def getUserRanking(self,account,callback):        #SELECT * FROM game.nettab_ranking where `id` = (select max(id) from game.nettab_ranking);        cmdstr = "SELECT * FROM game.nettab_ranking where account = '%s';\n"%(account) #查询某个玩家排行榜数据        askid = askMysqlType.SQL_SelectUserRanking        def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):            if len(mysqlobjtmp.data) > 0:                print mysqlobjtmp.data                datatmp = mysqlobjtmp.data[0]                if cback != None:                    cback(datatmp)            else:                print "未读取到最大排行榜数据"                if cback != None:                    cback(None)        if self.mysqlAsks.has_key(askid):            self.mysqlAsks[askid].append(selectMaxRanking)        else:            self.mysqlAsks[askid] = [selectMaxRanking]        self.askMysqlFromUser(askid,cmdstr,4)#account,askid,datas,mysqltype):    def getRankFront100(self):                                        #查询mysql最大排行榜数据        #SELECT * FROM game.nettab_ranking where `id` = (select max(id) from game.nettab_ranking);        cmdstr = "SELECT * FROM game.nettab_ranking limit 0,100;\n" #读取所有排行榜前100的数据        askid = askMysqlType.SQL_SelectUserRanking        def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = None):            if len(mysqlobjtmp.data) > 0:                print mysqlobjtmp.data                datatmp = mysqlobjtmp.data[0]            else:                print "未读取到最大排行榜数据"            if cback != None:                cback()        if self.mysqlAsks.has_key(askid):            self.mysqlAsks[askid].append(selectMaxRanking)        else:            self.mysqlAsks[askid] = [selectMaxRanking]        self.askMysqlFromUser(askid,cmdstr,4)#account,askid,datas,mysqltype):    def insetNewUserRanking(self,rankid,uname,value,account,callback):      #插入新排行榜数据        #INSERT INTO `game`.`nettab_ranking` (`id`, `name`, `attack`, `account`) VALUES ('4', '444', '444', 'ww');        cmdstr = "INSERT INTO `game`.`nettab_ranking` (`id`, `name`, `attack`, `account`) VALUES ('%d', '%s', '%d', '%s');\n"%(rankid,uname,value,account)        askid = askMysqlType.SQL_InsetUserRanking        def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):            if len(mysqlobjtmp.data) > 0:                print mysqlobjtmp.data            else:                print "插入排行榜数据"            if cback != None:                cback()        if self.mysqlAsks.has_key(askid):            self.mysqlAsks[askid].append(selectMaxRanking)        else:            self.mysqlAsks[askid] = [selectMaxRanking]        self.askMysqlFromUser(askid,cmdstr,4)#account,askid,datas,mysqltype):    def updataUserRankingForTowUser(self,uid1,news1,uid2,news2,callback):#         UPDATE `game`.`nettab_ranking` SET `name`='testy4', `attack`='1000' WHERE `id`='3';#         UPDATE `game`.`nettab_ranking` SET `name`='testx5', `attack`='998' WHERE `id`='1';#UPDATE `game`.`nettab_ranking` SET `name`='testy47', `attack`='88', `account`='ss' WHERE `id`='3';        cmdstr = "UPDATE `game`.`nettab_ranking` SET `name`='%s', `attack`='%d', `account`='%s' WHERE `id`='%d';\n"%(news1[0],news1[1],news1[2],uid1)        cmdstr += "UPDATE `game`.`nettab_ranking` SET `name`='%s', `attack`='%d', `account`='%s' WHERE `id`='%d';\n"%(news2[0],news2[1],news2[2],uid2)        askid = askMysqlType.SQL_UpdataUserRanking        def selectMaxRanking(mysqlobjtmp,paskid = askid,cback = callback):            if len(mysqlobjtmp.data) > 0:                print mysqlobjtmp.data            else:                print "插入排行榜数据"            if cback != None:                cback()        if self.mysqlAsks.has_key(askid):            self.mysqlAsks[askid].append(selectMaxRanking)        else:            self.mysqlAsks[askid] = [selectMaxRanking]        self.askMysqlFromUser(askid,cmdstr,4)#account,askid,datas,mysqltype):    def receiveDataFromMysqlConnectT(self,mysqlobj):#数据库数据返回        tmpkey = str(mysqlobj.account) + str(mysqlobj.askid)        self.receiveMysqlData(self.userMysqlAsks[tmpkey],mysqlobj)    def receiveMysqlData(self,askid,mysqlobj):        if self.mysqlAsks.has_key(askid):            backfunc = self.mysqlAsks[askid][0]            backfunc(mysqlobj)            self.mysqlAsks[askid][0] = None            if len(self.mysqlAsks[askid]) > 1:                self.mysqlAsks[askid] = self.mysqlAsks[askid][1:]            else:                self.mysqlAsks[askid] = []    def receiveDataFromUser(self,userdata,account):#从玩家处获取数据        if userdata.dataType == 'ranking':#获取排行榜数据            pass        elif userdata.dataType == 'warresult':#战斗结果数据            pass    def askMysqlFromUser(self,askid,cmdstr,mysqltype,account = 'userranking'):   #mysql数据正常操作        askkey = str(account) + str(askid)        self.userMysqlAsks[askkey] = askid        mysqlaskobj = QueueObjs.MysqlAskObj(askid,cmdstr,mysqltype,account)        if len(self.mysqlUnUsedQueues) > 0:            mysqlname,mysqlqueue = self.mysqlUnUsedQueues.popitem()            self.mysqlUsedQueues[mysqlname] = mysqlqueue            self.mysqlRequests[account] = mysqlname                                  queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)            #mysqlqueue.put(copy.deepcopy(queueobj))            mysqlqueue.put(queueobj)        else:            mysqlqueue,mysqlname = self.threadmangert.getCanUseMysqlThreadForOther(self.getName())            if mysqlqueue == None or mysqlname == None:                print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserCacheT)'            else:                self.mysqlUsedQueues[mysqlname] = mysqlqueue                self.mysqlRequests[account] = mysqlname                queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)                #mysqlqueue.put(copy.deepcopy(queueobj))                mysqlqueue.put(queueobj)    def askMysqlFromUserForInsetAutoID(self,askid,cmdstr1,cmdstrend,account = 'userranking'):   #使用自增加ID方式插入mysql数据库        askkey = str(account) + str(askid)        self.userMysqlAsks[askkey] = askid        cmdstrs = [cmdstr1,cmdstrend]        mysqlaskobj = QueueObjs.MysqlAskObj(askid,cmdstrs,5,account)        if len(self.mysqlUnUsedQueues) > 0:            mysqlname,mysqlqueue = self.mysqlUnUsedQueues.popitem()            self.mysqlUsedQueues[mysqlname] = mysqlqueue            self.mysqlRequests[account] = mysqlname                                  queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)            #mysqlqueue.put(copy.deepcopy(queueobj))            mysqlqueue.put(queueobj)        else:            mysqlqueue,mysqlname = self.threadmangert.getCanUseMysqlThreadForOther(self.getName())            if mysqlqueue == None or mysqlname == None:                print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserCacheT)'            else:                self.mysqlUsedQueues[mysqlname] = mysqlqueue                self.mysqlRequests[account] = mysqlname                queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)                #mysqlqueue.put(copy.deepcopy(queueobj))                mysqlqueue.put(queueobj)    def run(self):        while(True):            if not self.queueRequest.empty():                queueobj = self.queueRequest.get_nowait()                if self.mysqlUsedQueues.has_key(queueobj.fromTName):                    mysqlname = queueobj.fromTName                    mysqlqueu = self.mysqlUsedQueues.pop(mysqlname)                    if len(self.mysqlUnUsedQueues) > 1:                        self.threadmangert.releasMysqlControlForThreadName(self.getName(),mysqlname)                    else:                        self.mysqlUnUsedQueues[mysqlname] = mysqlqueu                    self.receiveDataFromMysqlConnectT(queueobj.data)                else:#为玩家请求排行榜数据或者玩家交换战斗结果数据                    self.receiveDataFromUser(queueobj.data, queueobj.data.account)                    