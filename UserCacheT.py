#!/usr/bin/env python# -*- coding: utf-8 -*-import osimport threadingimport Queueimport Userimport filedirtoolimport xlrdfrom QueueManger import QueueMangerimport QueueObjsimport randomimport hashlibclass UserCacheT(threading.Thread):    def __init__(self,t_name,cacheID,threadmangert):        threading.Thread.__init__(self, name=t_name)         self.threadmangert = threadmangert                  #线程管理对象        self.queuemangert = QueueManger.GetInstance()        self.queueRequest = Queue.Queue(2000)        self.queuemangert.saveThreadMailQueueWithName(t_name, self.queueRequest)        self.userMangerRespone = self.queuemangert.getThreadMailQueueWithName(self.threadmangert.userMangerName)        self.heaveUser = 0        self.userCacheID = cacheID                self.userMangerName = self.threadmangert.userMangerName        self.connectThreadName = self.threadmangert.connectThreadName                self.heros0 = []    #0,友情点抽取武将列表        self.herosQ0 = {}   #武将抽取权值{exid:qvalue}        self.randomRange0 = 0        self.heros1 = []    #1,88元宝抽取武将列表        self.herosQ1 = {}        self.randomRange1 = 0        self.heros2 = []    #2,188元宝抽取武将列表        self.herosQ2 = {}        self.randomRange2 = 0        self.heros3 = []    #3,188元宝10连抽得到武将列表        self.herosQ3 = {}        self.randomRange3 = 0                #商城显示道具        self.vipTabs = {}           #vip商品{商品位:{id:权值,...}}        self.itemTabs = {}          #道具商品{商品位:{id:权值,...}}        self.equipTabs = {}         #装备商品{商品位:{id:权值,...}}                        #基础配置表        self.configTables = self._getTables()        self._initRandomRecruitHeros()        self._initStoreWithTab()        #mysql        self.mysqlUnUsedQueues = {}        mysqlqueue,mysqlname = self.threadmangert.getCanUseMysqlThreadForOther(self.getName()) #mysql数据请求，需要时再请求，不用时马上释放连接,所以这里不作请求#mysql请求线程名                                     if mysqlqueue == None or mysqlname == None:            print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserMangerT)'        self.mysqlUnUsedQueues[mysqlname] = mysqlqueue              #已请法庭到的未使用的mysql连接        self.mysqlUsedQueues = {}                                   #正在使用的mysql连接        self.mysqlRequests = {}                                     #mysql请求编号{account:mysqlname}                self.userMysqlAsks = {}         #map:{account:askid}        #User        self.users = {}                 #map:{'account':account,'user':User}        self.userToken = {}             #map:{'account':token}        self.userAccount = {}           #map:{'token':account},通过用户token获取用户帐号        #多个用户共用mysql连接.这里保存mysql请求        #从本地读取基础配置数据到内存                #装备数据表        self.equips = {}                #{(装备类型*1000+装备品质):[装备ID,...]}装备类型,装备品质,从装备类型和品质中随机一个装备配置ID给熔练后生成的装备        self._initAllEquips()    def _initAllEquips(self):        equiptabs = self.getConfigTableWithTableName('tab_goods')        for goodid in equiptabs.keys():            goodtmp = equiptabs[goodid]            if int(goodtmp['goodType']) > 0:                goodtype = int(goodtmp['compose'])  #装备类型                goodrank = int(goodtmp['rank'])     #装备品质                tidx = goodtype*1000 + goodrank                if self.equips.has_key(tidx):                    self.equips[tidx].append(goodid)                else:                    self.equips[tidx] = [goodid]    def getEquipWithTypeAndRank(self,ptype,prank,isEquipList = False):        tidx = ptype*1000 + prank        if self.equips.has_key(tidx):            if isEquipList:                return self.equips[tidx]            else:                xtmp = random.randrange(0,len(self.equips[tidx]))                return self.equips[tidx][xtmp]        else:            return None    #读取excel数据表到list    def _getTables(self):        tables = {}        excelf = filedirtool.cur_file_dir() + os.sep + 'configTables' + os.sep + 'basescheme.xlsx'        xlrd.Book.encoding = "cp1252"        wb = xlrd.open_workbook(excelf)        for sheetName in wb.sheet_names():            if len(sheetName) > 4 and sheetName[:4]=="tab_":#基础配置表                sheet = wb.sheet_by_name(sheetName)                tabtmp = {}                tabcname = []                for i in range(0,sheet.ncols):                                if sheet.cell(0,i).value=='':                        nclows=i                        break                    else:                        tabcname.append(str(sheet.cell(0,i).value))                        nclows=sheet.ncols                               for rownum in range(0,sheet.nrows):                    if rownum > 3:                        tmplines = {}                        for nnumber in range(0,nclows):                            tmplines[tabcname[nnumber]] = sheet.cell(rownum,nnumber).value                        tabtmp[int(sheet.cell(rownum,0).value)] = tmplines                tables[sheetName] = tabtmp        return tables    #初始化商城数据    def _initStoreWithTab(self):        storeTabs = self.getConfigTableWithTableName('tab_store')        for idtmp in storeTabs.keys():            stortmp = storeTabs[idtmp]            if int(stortmp['down']) != 0:#物品是否下架                continue            if int(stortmp['store_type']) == 1:#vip商品                    self.vipTabs[int(stortmp['item_index'])] = {idtmp:int(stortmp['item_prob'])}            elif int(stortmp['store_type']) == 2:#道具商品                self.itemTabs[int(stortmp['item_index'])] = {idtmp:int(stortmp['item_prob'])}            elif int(stortmp['store_type']) == 3:#装备商品                self.equipTabs[int(stortmp['item_index'])] = {idtmp:int(stortmp['item_prob'])}                    def getMd5(self,strdata):        m = hashlib.md5()           m.update(str)        return m.hexdigest()    #获取一次商城出售物品列表    def getStoreGoodsForUser(self):        goods = []        for vipx in self.vipTabs.keys():            if len(self.vipTabs[vipx]) < 1:                continue            elif len(self.vipTabs[vipx]) == 1:                vk = self.vipTabs[vipx].keys()[0]                goods.append(vk)            else:                qvip = 0                itemmap = {}                for vk in self.vipTabs[vipx].keys():                    itemmap[vk] = [qvip]                    qvip += self.vipTabs[vipx][vk]                    itemmap[vk].append(qvip)                tmprandom = random.randrange(0,qvip)                 for vk in itemmap.keys():                    if tmprandom >= itemmap[vk][0] and tmprandom < itemmap[vk][1]:                        goods.append(vk)                        break        for vipx in self.itemTabs.keys():            if len(self.itemTabs[vipx]) < 1:                continue            elif len(self.itemTabs[vipx]) == 1:                vk = self.itemTabs[vipx].keys()[0]                goods.append(vk)            else:                qvip = 0                itemmap = {}                for vk in self.itemTabs[vipx].keys():                    itemmap[vk] = [qvip]                    qvip += self.itemTabs[vipx][vk]                    itemmap[vk].append(qvip)                tmprandom = random.randrange(0,qvip)                 for vk in itemmap.keys():                    if tmprandom >= itemmap[vk][0] and tmprandom < itemmap[vk][1]:                        goods.append(vk)                        break        for vipx in self.equipTabs.keys():            if len(self.equipTabs[vipx]) < 1:                continue            elif len(self.equipTabs[vipx]) == 1:                vk = self.equipTabs[vipx].keys()[0]                goods.append(vk)            else:                qvip = 0                itemmap = {}                for vk in self.equipTabs[vipx].keys():                    itemmap[vk] = [qvip]                    qvip += self.equipTabs[vipx][vk]                    itemmap[vk].append(qvip)                tmprandom = random.randrange(0,qvip)                 for vk in itemmap.keys():                    if tmprandom >= itemmap[vk][0] and tmprandom < itemmap[vk][1]:                        goods.append(vk)                        break        return goods    def _initRandomRecruitHeros(self):        herostab = self.getConfigTableWithTableName('tab_extractInfo')        self.randomRange0 = 0        self.randomRange1 = 0        self.randomRange2 = 0        self.randomRange3 = 0        for k in herostab.keys():            if int(herostab[k]['interval']) == 0:#友情抽取英雄                self.heros0.append(k)                self.herosQ0[k] = [self.randomRange0,self.randomRange0 + int(herostab[k]['weight']) -1 ]                self.randomRange0 += int(herostab[k]['weight'])             elif int(herostab[k]['interval']) == 1:#88元宝抽取英雄                self.heros1.append(k)                self.herosQ1[k] = [self.randomRange1,self.randomRange1 + int(herostab[k]['weight']) -1 ]                self.randomRange1 += int(herostab[k]['weight'])             elif int(herostab[k]['interval']) == 2:#188元宝抽取英雄                self.heros2.append(k)                self.herosQ2[k] = [self.randomRange2,self.randomRange2 + int(herostab[k]['weight']) -1 ]                self.randomRange2 += int(herostab[k]['weight'])             elif int(herostab[k]['interval']) == 3:#188元下连抽                self.heros3.append(k)                self.herosQ3[k] = [self.randomRange3,self.randomRange3 + int(herostab[k]['weight']) -1 ]                self.randomRange3 += int(herostab[k]['weight'])     #抽取武将:    def getHeroWithTypeAndCount(self,ptype,pcount):        if ptype == 0:#友情抽取英雄            heroks = []            for _x in range(pcount):                htmpk = random.randrange(0,self.randomRange0)                tmpk = 0                for k in self.herosQ0.keys():                    if htmpk >= self.herosQ0[k][0] and htmpk <= self.herosQ0[k][1]:                        tmpk = k                herotmp = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                heroks.append(herotmp)            return heroks        elif ptype == 1:#88元宝抽取英雄            heroks = []            for _x in range(pcount):                htmpk = random.randrange(0,self.randomRange1)                tmpk = 0                for k in self.herosQ1.keys():                    if htmpk >= self.herosQ1[k][0] and htmpk <= self.herosQ1[k][1]:                        tmpk = k                herotmp = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                heroks.append(herotmp)            return heroks        elif ptype == 2:#188元宝抽取英雄            heroks = []            if pcount >= 10:                newcount = pcount - 1                for _x in range(newcount):                    htmpk = random.randrange(0,self.randomRange2)                    tmpk = 0                    for k in self.herosQ2.keys():                        if htmpk >= self.herosQ2[k][0] and htmpk <= self.herosQ2[k][1]:                            tmpk = k                    herotmp = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                    heroks.append(herotmp)                #10连抽多一个抽取牛B武将的机会                htmp3k = random.randrange(0,self.randomRange3)                tmpk = 0                for k in self.herosQ3.keys():                    if htmp3k >= self.herosQ3[k][0] and htmp3k <= self.herosQ3[k][1]:                        tmpk = k                herotmp3 = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                heroks.append(herotmp3)            else:                newcount = pcount - 1                for _x in range(newcount):                    htmpk = random.randrange(0,self.randomRange2)                    tmpk = 0                    for k in self.herosQ2.keys():                        if htmpk >= self.herosQ2[k][0] and htmpk <= self.herosQ2[k][1]:                            tmpk = k                    herotmp = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                    heroks.append(herotmp)            return heroks        elif ptype == 3:#188元下连抽            heroks = []            for _x in range(pcount):                htmpk = random.randrange(0,self.randomRange3)                tmpk = 0                for k in self.herosQ3.keys():                    if htmpk >= self.herosQ3[k][0] and htmpk <= self.herosQ3[k][1]:                        tmpk = k                herotmp = self.getConfigDataWithTableNameAndID('tab_extractInfo', tmpk)                heroks.append(herotmp)            return heroks        def getConfigDataWithTableNameAndID(self,tabName,confID):        if self.configTables.has_key(tabName) and self.configTables[tabName].has_key(confID):            return self.configTables[tabName][confID]        else:            return None    def getConfigTableWithTableName(self,tabName):        if self.configTables.has_key(tabName):            return self.configTables[tabName]        else:            return None    def createUserWithUserObj(self,userobj,account):        self.users[account] = User.User(account,userobj.data,self)#account,clientobj,mysqlTRequestQueue,mysqlEvent,userCacheT):    def sendEmailDataToUserManger(self,fromName,toAccount,emailNid,emailType):        userstatuseobj = QueueObjs.UserStatusObj(emailType,'email',fromName,toAccount,emailNid)        queueobj =  QueueObjs.QueueMangerObj(userstatuseobj,QueueObjs.Flog_UserStatusObj,self.getName(),self.userMangerName)        #self.userMangerRespone.put(copy.deepcopy(queueobj))        self.userMangerRespone.put(queueobj)    def UserComplete(self,account,ptype = 'login'):#用户对象回调用户线程池对象方法,type:0.创建用户结束，请求创建连接缓存转发功能并启动用户管理线程中用户token过期定时器        userstatuseobj = QueueObjs.UserStatusObj('','login',account,self.userToken[account],self.getName())#(self,dat,dataType,account,token,cID):        queueobj =  QueueObjs.QueueMangerObj(userstatuseobj,QueueObjs.Flog_UserStatusObj,self.getName(),self.userMangerName)        #self.userMangerRespone.put(copy.deepcopy(queueobj))        self.userMangerRespone.put(queueobj)    def askMysqlFromUser(self,account,askid,cmdstr,mysqltype):        askkey = str(account) + str(askid)        self.userMysqlAsks[askkey] = askid        mysqlaskobj = QueueObjs.MysqlAskObj(askid,cmdstr,mysqltype,account)        if len(self.mysqlUnUsedQueues) > 0:            mysqlname,mysqlqueue = self.mysqlUnUsedQueues.popitem()            self.mysqlUsedQueues[mysqlname] = mysqlqueue            self.mysqlRequests[account] = mysqlname                                  queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)            #mysqlqueue.put(copy.deepcopy(queueobj))            mysqlqueue.put(queueobj)        else:            mysqlqueue,mysqlname = self.threadmangert.getCanUseMysqlThreadForOther(self.getName())            if mysqlqueue == None or mysqlname == None:                print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserCacheT)'            else:                self.mysqlUsedQueues[mysqlname] = mysqlqueue                self.mysqlRequests[account] = mysqlname                queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)                #mysqlqueue.put(copy.deepcopy(queueobj))                mysqlqueue.put(queueobj)    def askMysqlFromUserForInsetAutoID(self,account,askid,cmdstr1,cmdstrend):        askkey = str(account) + str(askid)        self.userMysqlAsks[askkey] = askid        cmdstrs = [cmdstr1,cmdstrend]        mysqlaskobj = QueueObjs.MysqlAskObj(askid,cmdstrs,5,account)        if len(self.mysqlUnUsedQueues) > 0:            mysqlname,mysqlqueue = self.mysqlUnUsedQueues.popitem()            self.mysqlUsedQueues[mysqlname] = mysqlqueue            self.mysqlRequests[account] = mysqlname                                  queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)            #mysqlqueue.put(copy.deepcopy(queueobj))            mysqlqueue.put(queueobj)        else:            mysqlqueue,mysqlname = self.threadmangert.getCanUseMysqlThreadForOther(self.getName())            if mysqlqueue == None or mysqlname == None:                print '错误:mysql线程请求错误,UserMangerT未请求到可用Mysql连接线程(UserCacheT)'            else:                self.mysqlUsedQueues[mysqlname] = mysqlqueue                self.mysqlRequests[account] = mysqlname                queueobj = QueueObjs.QueueMangerObj(mysqlaskobj,QueueObjs.Flog_MysqlAskObj,self.getName(),mysqlname,True)                #mysqlqueue.put(copy.deepcopy(queueobj))                mysqlqueue.put(queueobj)    def receiveMysqlRespone(self,mysqlobj):        tmpkey = str(mysqlobj.account) + str(mysqlobj.askid)        self.users[mysqlobj.account].receiveMysqlData(self.userMysqlAsks[tmpkey],mysqlobj)    def receiveUserMangerTRequest(self,queueobj):        if queueobj.dataType == QueueObjs.Flog_UserObj:#收到userManger线程发来的创建用户信息,用户登陆或者用户注册            account = queueobj.data.account            if queueobj.data.dataType == 'email':                if self.users.has_key(account):                    self.users[account].receiveDataFromUserMangerT(queueobj.data)            else:                ttoken = queueobj.data.data.handler.tea                if self.users.has_key(account):                    if self.userToken.has_key(account):                        _oldToken = self.userAccount.pop(self.userToken[account])                        self.userToken[account] = ttoken                        self.userAccount[ttoken] = account                        self.users[account].receiveDataFromUserMangerT(queueobj.data)                else:                    self.userAccount[ttoken] = account                    self.userToken[account] = ttoken                    self.createUserWithUserObj(queueobj.data, account)#         elif queueobj.dataType == 'email':#             self.receiveEmailFromUserManger(queueobj.data)#         elif queueobj.dataType == 'connectlogin':#用户登陆成功，并得到连接转发#             self.connectCreateOK(queueobj.data)#         elif queueobj.dataType == 'connect':#收到客户端发来的游戏接口请求#             self.receiveDataFromConnectCache(queueobj.data)#     #用户连接创建完成，可以向玩家发送用户信息，以及保存用户数据到mysql数据库中#     def connectCreateOK(self,userstatusobj):#         if self.users.has_key(userstatusobj.account):#             self.users[userstatusobj.account].receiveConnectCacheCreatOK(userstatusobj)    #接收到来自用户的游戏接口请求数据    def receiveDataFromConnectCache(self,clientobj):        if self.userAccount.has_key(clientobj.handler.tea):            self.users[self.userAccount[clientobj.handler.tea]].receiveClientDataFromConnectCache(clientobj)#             try:#                 self.users[self.userAccount[clientobj.handler.tea]].receiveClientDataFromConnectCache(clientobj)#             except EOFError,e:  #                 print '接受客户端数据出错' #                 print e#                 print EOFError  #             except EOFError,e:  #                 print '接受客户端数据出错' #                 print EOFError  #             except:  #                 print '接受客户端数据出错'    def run(self):        while(True):            if not self.queueRequest.empty():                queueobj = self.queueRequest.get_nowait()                if queueobj.fromTName == self.userMangerName:               #收到用户管理器发来消息                    self.receiveUserMangerTRequest(queueobj)                elif queueobj.fromTName == self.connectThreadName:          #收到连接管理器发来数据                    self.receiveDataFromConnectCache(queueobj.data)                elif self.mysqlUsedQueues.has_key(queueobj.fromTName):            #收到mysql发来数据                    mysqlname = queueobj.fromTName                    mysqlqueu = self.mysqlUsedQueues.pop(mysqlname)                    if len(self.mysqlUnUsedQueues) > 1:                        self.threadmangert.releasMysqlControlForThreadName(self.getName(),mysqlname)                    else:                        self.mysqlUnUsedQueues[mysqlname] = mysqlqueu                    self.receiveMysqlRespone(queueobj.data)        