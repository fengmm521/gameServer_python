#!/usr/bin/env python# -*- coding: utf-8 -*-#线程管理器，这里创建和保存所有线程import threadingfrom QueueManger import QueueMangerimport MySqlConnectTimport UserMangerTimport UserCacheTimport UserConnectCacheTimport QueueObjsfrom UserRankingT import UserRankingT#单例类线程管理器class ThreadManger():    instance=None    mutex=threading.Lock()    def __init__(self):        self.threadTypes = ['mysql','connect','usercache','usermanger']             #线程管理器中默认包含的工作线程类型        #mysql数据库        self.mysqlThreads = {}                                                      #数据库访问线程池        self.mysqlThreadNames = []                                                  #所有mysql连接线程编号        self.mysqlCanUsedThreads = []                                               #当前空闭的连接线程编号        self.mysqlThreadUsers = {}                                                  #当前使用mysql连接线程的用户线程名        self.mysqlIndex = 1        self.mysqlMax = 100        self.mysqltfrontName = 'mysqlthread'                #用户帐号管理器线程        self.userMangerThread = None                                                #客户端登陆管理线程组        self.userMangerName = 'UserMangerT'                                         #用户管理线程名        #客户端连接转发线程        self.connectThread = None                                                  #客户端连接线程池        self.connectThreadName = 'UserConnectCacheT'        #玩家排行榜线程        self.userRankingThread = None                                               #玩家排行榜线程        self.userRankingName = 'UserRankingT'                                       #玩家排行榜线程名                #用户线程池        self.userCacheThreads = {}                                                  #客户端数据组缓存池        self.userCacheTNames = []                                                   #客户端数据组缓存池名称后缀编号        self.cacheHeaveUserNames = {}                                               #当前用户数据组缓存中玩家名称{缓存编号:[account1,account2,...]}        self.userForCache = {}                                                      #当前登陆的用户名所在缓存池编号        self.userCacheIndex = 1        self.userCacheMax = 100                                                     #最大用户线程池        self.userCacheFrontName = 'userCthread'                                     #用户线程名称前缀                #主线程名        self.mainThreadName = 'maint'                                                       #线程列队        self.queumangert = QueueManger.GetInstance()                            #线程邮箱列队管理器,负责线程间使用线程名进行通信        self.threadNames = []            @staticmethod    def GetInstance():        if(ThreadManger.instance==None):            ThreadManger.mutex.acquire()            ThreadManger.instance=ThreadManger()            ThreadManger.mutex.release()        return ThreadManger.instance    #获取用户管理线程接收邮箱列队    def getUserMangerThreadQueue(self):        if self.userMangerThread == None:            self.userMangerThread = UserMangerT.UserMangerT(self.userMangerName,self)            self.userMangerThread.setDaemon(True)            self.userMangerThread.start()            return self.queumangert.getThreadMailQueueWithName(self.userMangerName)        else:            return self.queumangert.getThreadMailQueueWithName(self.userMangerName)    #获取连接线程    def getConnectCacheThreadQueue(self):        if self.connectThread == None:            self.connectThread = UserConnectCacheT.UserConnectCacheT(self.connectThreadName,self)            self.connectThread.setDaemon(True)            self.connectThread.start()            return self.queumangert.getThreadMailQueueWithName(self.connectThreadName)        else:            return self.queumangert.getThreadMailQueueWithName(self.connectThreadName)            #获取用户排行榜线程邮箱    def getUserRankingThreadQueue(self):        if self.userRankingThread == None:            self.userRankingThread = UserRankingT(self.userRankingName,self)            self.userRankingThread.setDaemon(True)            self.userRankingThread.start()            return self.queumangert.getThreadMailQueueWithName(self.userRankingName)        else:            return self.queumangert.getThreadMailQueueWithName(self.userRankingName)    #测试玩家帐号是否已存在,存在则返回玩家线程列队和用户缓存名,使用此方法可以通过用户管理线程完成两个玩家数据交互,如邮件发送，聊天消息发送等等    def getUserWorkUserCacheTQueueWithAccount(self,account):        if self.userForCache.has_key(account):            usercfName = self.userCacheFrontName + str(self.userForCache[account])            return self.queumangert.getThreadMailQueueWithName(usercfName),usercfName        else:            return None,None    #获取用户线程用户数量    def getUserCountFromUserCache(self,cacheName):        if self.cacheHeaveUserNames.has_key(cacheName):            return len(self.cacheHeaveUserNames)        else:            return -1    #用户线程池部分,为用户管理线程分配一个客户端用户数据处理线程池，并返回线程池接收数据列队以及线程名    def getCanUseUserCacheThreadTForUserMangerTWithUser(self,account):        usercfName = ''        if not self.queumangert.isExistThreadWithName(self.userMangerName):            print '错误:用户管理线程未注册接收邮箱'            return None,None        if self.userCacheIndex > 100:            print '错误:用户线程已达最大数'            return None,None        if self.userForCache.has_key(account):                                        #用户线程池中已有当前用户            print '测试:线程池中已有当前用户'            usercfName = self.userCacheFrontName + str(self.userForCache[account])            return self.queumangert.getThreadMailQueueWithName(usercfName),usercfName        #用户线程池中没有用户，在用户线程池中创建用户,        minCount = 999        minCountID = ''        for x in self.cacheHeaveUserNames.keys():            if len(self.cacheHeaveUserNames[x]) < minCount:                minCount = len(self.cacheHeaveUserNames[x])                minCountID = x        if minCount < self.userCacheMax:            usercfName = minCountID            #self.queumangert.sendDataToThreadWithName(queuemangerobj.data, queuemangerobj.fromTName,usercfName,queuemangerobj.dataType,True)  #在用户线程池中创建一个用户            return self.queumangert.getThreadMailQueueWithName(usercfName),usercfName        else:#用户已有用户线程池已满，创建一个新的用户缓存线程            usercfName = self.userCacheFrontName + str(self.userCacheIndex)            self.userCacheThreads[usercfName] = UserCacheT.UserCacheT(usercfName,self.userCacheIndex,self)            self.userCacheThreads[usercfName].setDaemon(True)            self.userCacheThreads[usercfName].start()            self.userForCache[account] = self.userCacheIndex            self.userCacheIndex += 1            #self.queumangert.sendDataToThreadWithName(queuemangerobj.data, queuemangerobj.fromTName,usercfName,queuemangerobj.dataType,True)            return self.queumangert.getThreadMailQueueWithName(usercfName),usercfName    def delUserFromUserCacheWithAccount(self,useraccount,threadName = ''):#用户登陆超时，删除用户缓存数据,默认消息由用户管理对象发出        usercfName = ''        fromName = threadName        if fromName == '':            fromName = self.userMangerName        if self.userForCache.has_key(useraccount):            usercfName = self.userCacheFrontName + str(self.userForCache[useraccount])            self.queumangert.sendDataToThreadWithName('logintimeout', fromName, usercfName, True)        else:            print "错误:用户不在用户缓存中(delUserFromUserCacheWithAccount)"    def createNewMysqlThread(self):        while(len(self.mysqlCanUsedThreads) < 10):            mysqltname = self.mysqltfrontName + str(self.mysqlIndex)            self.mysqlThreads[mysqltname] = MySqlConnectT.connectThread(mysqltname,'',self)             self.mysqlThreads[mysqltname].setDaemon(True)            self.mysqlThreads[mysqltname].start()            self.mysqlCanUsedThreads.append(self.mysqlIndex)            self.mysqlThreadNames.append(self.mysqlIndex)                        #记下创建的数据库连接线程名称            self.mysqlIndex += 1    #mysql数据库部分    def getCanUseMysqlThreadForOther(self,OtherTName):                              #为某个线程名申请mysql请求线程列队        mysqltname = OtherTName        if not self.queumangert.isExistThreadWithName(OtherTName):            print "错误:线程未注册接收邮箱"            return None,None        if self.mysqlIndex > 1600:            print "错误:数据库已达最大线程数"            return None,None        elif len(self.mysqlCanUsedThreads) > 0:            canusedid = self.mysqlCanUsedThreads.pop()            mysqltname = self.mysqltfrontName + str(canusedid)            queueobj = QueueObjs.MysqlAskObj(0,OtherTName,0)            self.queumangert.sendDataToThreadWithName(queueobj,QueueObjs.Flog_MysqlAskObj, OtherTName, mysqltname)   #给mysql线程设置新工作回报线程            self.mysqlThreadUsers[mysqltname] = canusedid            #self.createNewMysqlThread()            return self.queumangert.getThreadMailQueueWithName(mysqltname),mysqltname        else:            mysqltname = self.mysqltfrontName + str(self.mysqlIndex)            self.mysqlThreads[mysqltname] = MySqlConnectT.connectThread(mysqltname,OtherTName,self)             self.mysqlThreads[mysqltname].setDaemon(True)            self.mysqlThreads[mysqltname].start()            self.mysqlThreadUsers[mysqltname] = self.mysqlIndex                  #记下数据库请求的当前控制线程            self.mysqlThreadNames.append(self.mysqlIndex)                   #记下创建的数据库连接线程名称            self.mysqlIndex += 1            return self.queumangert.getThreadMailQueueWithName(mysqltname),mysqltname    def releasMysqlControlForThreadName(self,otherTName,mysqlname):                   #线程释放mysql连接线程控制权        tnumber =  self.mysqlThreadUsers.pop(mysqlname)        queueobj = QueueObjs.MysqlAskObj(0,otherTName,-1)        self.queumangert.sendDataToThreadWithName(queueobj,QueueObjs.Flog_MysqlAskObj, otherTName, mysqlname)   #给mysql线程设置新工作回报线程        self.mysqlCanUsedThreads.append(tnumber)                        